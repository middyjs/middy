{"searchDocs":[{"title":"Connection reuse","type":0,"sectionRef":"#","url":"/docs/best-practices/connection-reuse","content":"Connection reuse Be sure to set the following environment variable when connecting to AWS services: AWS_NODEJS_CONNECTION_REUSE_ENABLED=1 This allows you to reuse the first connection established across lambda invocations. See Reusing Connections with Keep-Alive in Node.js","keywords":"","version":"Next"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/","content":"","keywords":"","version":"Next"},{"title":"What is middy​","type":1,"pageTitle":"Introduction","url":"/docs/#what-is-middy","content":" Middy is a very simple middleware engine that allows you to simplify your AWS Lambda code when using Node.js.  If you have used web frameworks like Express, then you will be familiar with the concepts adopted in Middy and you will be able to get started very quickly.  A middleware engine allows you to focus on the strict business logic of your Lambda and then attach additional common elements like authentication, authorization, validation, serialization, etc. in a modular and reusable way by decorating the main business logic.  ","version":"Next","tagName":"h2"},{"title":"A quick example​","type":1,"pageTitle":"Introduction","url":"/docs/#a-quick-example","content":" Code is better than 10,000 words, so let's jump into an example.  Let's assume you are building a JSON API to process a payment:  handler.js // import core import middy from '@middy/core' // esm Node v14+ //const middy = require('@middy/core') // commonjs Node v12+ // import some middlewares import jsonBodyParser from '@middy/http-json-body-parser' import httpErrorHandler from '@middy/http-error-handler' import validator from '@middy/validator' import { transpileSchema } from '@middy/validator/transpile' // This is your common handler, in no way different than what you are used to doing every day in AWS Lambda const lambdaHandler = async (event, context) =&gt; { // we don't need to deserialize the body ourself as a middleware will be used to do that const { creditCardNumber, expiryMonth, expiryYear, cvc, nameOnCard, amount } = event.body // do stuff with this data // ... const response = { result: 'success', message: 'payment processed correctly' } return { statusCode: 200, body: JSON.stringify(response) } } // Notice that in the handler you only added base business logic (no deserialization, // validation or error handler), we will add the rest with middlewares const schema = { type: 'object', properties: { body: { type: 'object', properties: { creditCardNumber: { type: 'string', minLength: 12, maxLength: 19, pattern: '\\\\d+' }, expiryMonth: { type: 'integer', minimum: 1, maximum: 12 }, expiryYear: { type: 'integer', minimum: 2017, maximum: 2027 }, cvc: { type: 'string', minLength: 3, maxLength: 4, pattern: '\\\\d+' }, nameOnCard: { type: 'string' }, amount: { type: 'number' } }, required: ['creditCardNumber'] // Insert here all required event properties } } } // Let's &quot;middyfy&quot; our handler, then we will be able to attach middlewares to it export const handler = middy() .use(jsonBodyParser()) // parses the request body when it's a JSON and converts it to an object .use(validator({ eventSchema: transpileSchema(schema) })) // validates the input .use(httpErrorHandler()) // handles common http errors and returns proper responses .handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Why?​","type":1,"pageTitle":"Introduction","url":"/docs/#why","content":" One of the main strengths of serverless and AWS Lambda is that, from a developer perspective, your focus is mostly shifted toward implementing business logic.  Anyway, when you are writing a handler, you still have to deal with some common technical concerns outside business logic, like input parsing and validation, output serialization, error handling, etc.  Very often, all this necessary code ends up polluting the pure business logic code in your handlers, making the code harder to read and to maintain.  In other contexts, like generic web frameworks (fastify, hapi, express, etc.), this problem has been solved using the middleware pattern.  This pattern allows developers to isolate these common technical concerns into&quot;steps&quot; that decorate the main business logic code. Middleware functions are generally written as independent modules and then plugged into the application in a configuration step, thus not polluting the main business logic code that remains clean, readable, and easy to maintain.  Since we couldn't find a similar approach for AWS Lambda handlers, we decided to create middy, our own middleware framework for serverless in AWS land. ","version":"Next","tagName":"h2"},{"title":"Intro","type":0,"sectionRef":"#","url":"/docs/best-practices/intro","content":"Intro In this section you will find some common tips and tricks to ensure you don't hit any performance or security issues. Did we miss something? Let us know.","keywords":"","version":"Next"},{"title":"Small node_modules","type":0,"sectionRef":"#","url":"/docs/best-practices/small-node-modules","content":"Small node_modules Using a bundler is the optimal solution, but can be complex depending on your setup. In this case you should remove excess files from your node_modules directory to ensure it doesn't have anything excess shipped to AWS. We put together a .yarnclean file you can check out and use as part of your CI/CD process: .yarnclean # -- Middy.js -- # Dependencies **/ajv/lib **/ajv/.runkit_examples.js **/ajv-errors/src **/ajv-formats/src **/ajv-formats-draft2019/.github **/ajv-formats-draft2019/.prettierrc.js **/ajv-formats-draft2019/index.test.js **/ajv-i18n/localize/.eslintrc.yml **/json-mask/bin **/json-mask/build **/qs/.github **/qs/dist **/qs/test **/qs/.editorconfig **/qs/.eslintrc **/qs/.nycrc **/qs/CHANGELOG.md # DevDependencies **/@types **/@serverless/event-mocks ## Sub[/Sub] Dependencies **/bowser/src **/bowser/bundled.js **/dicer/bench **/dicer/test **/inherits/inherits_browser.js **/json-schema-traverse/.github **/json-schema-traverse/spec **/fast-deep-equal/es6 **/fast-deep-equal/react.js **/querystring/test **/react-native-get-random-values/android **/react-native-get-random-values/ios **/react-native-get-random-values/index.web.js **/react-native-get-random-values/react-native-get-random-values.podspec **/setprototypeof/test **/tslib **/uri-js/dist/esnext **/url/.zuul.yml **/url/test.js **/uuid/bin # Builds *.ts tsconfig.json *.js.map package-lock.json yarn.lock .travis.yml # Common .bin .cache .editorconfig .eslintignore .eslintrc .eslintrc.yml .gitattributes .npmignore AUTHORS LICENSE *.md *.txt ","keywords":"","version":"Next"},{"title":"Bundling Lambda packages","type":0,"sectionRef":"#","url":"/docs/best-practices/bundling","content":"","keywords":"","version":"Next"},{"title":"Compilers​","type":1,"pageTitle":"Bundling Lambda packages","url":"/docs/best-practices/bundling#compilers","content":" ","version":"Next","tagName":"h2"},{"title":"typescript​","type":1,"pageTitle":"Bundling Lambda packages","url":"/docs/best-practices/bundling#typescript","content":" npm i -D typescript node_modules/.bin/tsc   tsconfig.json​  { &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;./&quot;, &quot;esModuleInterop&quot;: true, &quot;preserveConstEnums&quot;: true, &quot;strictNullChecks&quot;: true, &quot;allowJs&quot;: false, &quot;target&quot;: &quot;es2021&quot;, &quot;typeRoots&quot;: [&quot;node_modules/@types&quot;], &quot;resolveJsonModule&quot;: true, &quot;moduleResolution&quot;: &quot;node&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Bundlers​","type":1,"pageTitle":"Bundling Lambda packages","url":"/docs/best-practices/bundling#bundlers","content":" ","version":"Next","tagName":"h2"},{"title":"esbuild​","type":1,"pageTitle":"Bundling Lambda packages","url":"/docs/best-practices/bundling#esbuild","content":" npm i -D esbuild # --banner:js hack from https://github.com/evanw/esbuild/pull/2067 node_modules/.bin/esbuild index.js \\ --platform=node --format=esm --target=node18 --bundle --minify \\ --banner:js=&quot;import { createRequire } from 'module';const require = createRequire(import.meta.url);&quot; \\ --legal-comments=external --sourcemap=external \\ --allow-overwrite --outfile=index.mjs   ","version":"Next","tagName":"h3"},{"title":"Internal Context","type":0,"sectionRef":"#","url":"/docs/best-practices/internal-context","content":"Internal Context Middy is built to be async even at it's core. Middlewares can set promises to internal. This approach allows them to be resolved together just when you need them. import middy from '@middy/core' import {getInternal} from '@middy/util' const lambdaHandler = async (event, context, { signal }) =&gt; { } const config = { internal: new Proxy({}, { get: (target, prop, receiver) =&gt; { // ... return Reflect.get(...arguments) }, set: (obj, prop, value) =&gt; { // ... ie if `prop` changes, trigger something obj[prop] = value return true } }) } export const handler = middy(config) // Incase you want to add values on to internal directly .before((async (request) =&gt; { request.internal = { env: process.env.NODE_ENV } })) .use(sts(...)) .use(ssm(...)) .use(rdsSigner(...)) .use(secretsManager(...)) .before(async (request) =&gt; { // internal == { key: 'value' } // Map with same name Object.assign(request.context, await getInternal(['key'], request)) // -&gt; context == { key: 'value'} // Map to new name Object.assign(request.context, await getInternal({'newKey':'key'}, request)) // -&gt; context == { newKey: 'value'} // get all the values, only if you really need to, // but you should only request what you need for the handler Object.assign(request.context, await getInternal(true, request)) // -&gt; context == { key: 'value'} }) .handler(lambdaHandler) ","keywords":"","version":"Next"},{"title":"rollup​","type":1,"pageTitle":"Bundling Lambda packages","url":"/docs/best-practices/bundling#rollup","content":" npm i -D rollup @rollup/plugin-node-resolve @rollup/plugin-commonjs node_modules/.bin/rollup --config   rollup.config.mjs​  import { nodeResolve } from '@rollup/plugin-node-resolve' import commonjs from '@rollup/plugin-commonjs' const plugins = [nodeResolve({ preferBuiltins: true }), commonjs()] export default (input) =&gt; ({ input: 'index.js', output: { file: 'index.bundle.rollup.mjs', format: 'es' // cjs, es }, plugins, external: [ // AWS SDK '@aws-sdk/client-apigatewaymanagementapi', // @middy/ws-response '@aws-sdk/client-rds', // @middy/rds-signer '@aws-sdk/client-s3', // @middy/s3-object-response '@aws-sdk/client-secretsmanager', // @middy/sercrets-manager '@aws-sdk/client-servicediscovery', // @middy/service-discovery '@aws-sdk/client-ssm', // @middy/ssm '@aws-sdk/client-sts' // @middy/sts ] })   ","version":"Next","tagName":"h3"},{"title":"swc/pack​","type":1,"pageTitle":"Bundling Lambda packages","url":"/docs/best-practices/bundling#swcpack","content":" npm i -D @swc/cli @swc/core node_modules/.bin/spack   caution Incomplete  ","version":"Next","tagName":"h3"},{"title":"webpack​","type":1,"pageTitle":"Bundling Lambda packages","url":"/docs/best-practices/bundling#webpack","content":" npm i -D webpack-cli webpack node_modules/.bin/webpack   webpack.config.mjs​  import path from 'node:path' import { fileURLToPath } from 'node:url' const __filename = fileURLToPath(import.meta.url) const __dirname = path.dirname(__filename) export default { mode: 'development', entry: './index.js', output: { filename: 'index.bundle.webpack.mjs', path: __dirname }, experiments: { outputModule: true }, externals: [ // NodeJS modules 'events', // @middy/core 'https', // @middy/s3-object-response 'stream', // @middy/http-content-encoding @middy/s3-object-response 'util', // @middy/http-content-encoding 'zlib', // @middy/http-content-encoding // AWS SDK '@aws-sdk/client-apigatewaymanagementapi', // @middy/ws-response '@aws-sdk/client-rds', // @middy/rds-signer '@aws-sdk/client-s3', // @middy/s3-object-response '@aws-sdk/client-secretsmanager', // @middy/sercrets-manager '@aws-sdk/client-servicediscovery', // @middy/service-discovery '@aws-sdk/client-ssm', // @middy/ssm '@aws-sdk/client-sts' // @middy/sts ] }   ","version":"Next","tagName":"h3"},{"title":"Transpilers​","type":1,"pageTitle":"Bundling Lambda packages","url":"/docs/best-practices/bundling#transpilers","content":" ","version":"Next","tagName":"h2"},{"title":"babel​","type":1,"pageTitle":"Bundling Lambda packages","url":"/docs/best-practices/bundling#babel","content":" npm i -D @babel/cli @babel/core @babel/preset-env node_modules/.bin/babel index.js --out-file index.transpile.babel.cjs   babel.config.json​  { &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, { &quot;targets&quot;: { &quot;node&quot;: &quot;16&quot; } } ] ] }   ","version":"Next","tagName":"h3"},{"title":"esbuild​","type":1,"pageTitle":"Bundling Lambda packages","url":"/docs/best-practices/bundling#esbuild-1","content":" npm i -D esbuild node_modules/.bin/esbuild --platform=node --target=node16 --format=cjs index.js --outfile=index.cjs   ","version":"Next","tagName":"h3"},{"title":"swc​","type":1,"pageTitle":"Bundling Lambda packages","url":"/docs/best-practices/bundling#swc","content":" npm i -D @swc/cli @swc/core node_modules/.bin/swc index.js --out-file index.transpile.swc.cjs   .swcrc​  { &quot;jsc&quot;: { &quot;parser&quot;: { &quot;syntax&quot;: &quot;ecmascript&quot; }, &quot;target&quot;: &quot;es2021&quot; }, &quot;module&quot;: { &quot;type&quot;: &quot;commonjs&quot; } }  ","version":"Next","tagName":"h3"},{"title":"Profiling","type":0,"sectionRef":"#","url":"/docs/best-practices/profiling","content":"","keywords":"","version":"Next"},{"title":"Time​","type":1,"pageTitle":"Profiling","url":"/docs/best-practices/profiling#time","content":"  const defaults = { logger: console.log, enabled: true } const timePlugin = (opts = {}) =&gt; { const { logger, enabled } = { ...defaults, ...opts } const store = {} const start = (id) =&gt; { store[id] = process.hrtime.bigint() } const stop = (id) =&gt; { if (!enabled) return logger(id, Number.parseInt((process.hrtime.bigint() - store[id]).toString()) / 1000000, 'ms') } // Only run during cold start const beforePrefetch = () =&gt; start('total') const requestStart = () =&gt; { if (!store.init) { store.init = store.total stop('init') } else { start('total') } } const beforeMiddleware = start const afterMiddleware = stop const beforeHandler = () =&gt; start('handler') const afterHandler = () =&gt; stop('handler') const requestEnd = () =&gt; stop('total') return { beforePrefetch, requestStart, beforeMiddleware, afterMiddleware, beforeHandler, afterHandler, requestEnd } } export const handler = middy(timePlugin()) .use(eventLogger()) .use(errorLogger()) .use(httpEventNormalizer()) .use(httpHeaderNormalizer()) .use(httpUrlencodePathParametersParser()) .use(httpUrlencodeBodyParser()) .use(httpJsonBodyParser()) .use(httpCors()) .use(httpSecurityHeaders()) .use(validator({eventSchema})) .handler(()=&gt;{}) await handler()   This will log out something this:  inputOutputLoggerMiddlewareBefore 0.156033 ms httpEventNormalizerMiddlewareBefore 0.073921 ms httpHeaderNormalizerMiddlewareBefore 0.095098 ms httpUrlencodePathParserMiddlewareBefore 0.036255 ms httpUrlencodeBodyParserMiddlewareBefore 0.038809 ms httpJsonBodyParserMiddlewareBefore 0.048383 ms httpContentNegotiationMiddlewareBefore 0.042311 ms validatorMiddlewareBefore 0.083366 ms handler 0.094875 ms validatorMiddlewareAfter 0.083601 ms httpSecurityHeadersMiddlewareAfter 0.19702 ms httpCorsMiddlewareAfter 0.080532 ms inputOutputLoggerMiddlewareAfter 0.066886 ms lambda 66.141835 ms   From this everything looks good. Sub 1ms for every middleware and the handler. But wait, that total doesn't look right. You're correct, total includes the initial setup time (or cold start time) for all middlewares. In this case validator is the culprit. The Ajv constructor and compiler do a lot of magic when they first run to get ready for later schema validations. This is why in the validator middleware we now support passing in complied schema and expose the default compiler in case you want to use it in a build step. We hope this feature will help to you in identify slow middlewares and improve your development experience.  There is also a beforeRequest hook, but was left out of the example for dramatic effect.  Additionally, you'll notice that each middleware shows a descriptive name. This is printing out the function name passed into middy core. If you've looked at the code for some the supported middlewares, you'll see these long descriptive variable names being set, then returned. This is why.  ","version":"Next","tagName":"h2"},{"title":"Memory​","type":1,"pageTitle":"Profiling","url":"/docs/best-practices/profiling#memory","content":" import memwatch from '@airbnb/node-memwatch' const defaults = { logger: console.log } const memoryPlugin = (opts = {}) =&gt; { const { logger } = { ...defaults, ...opts } const store = {} const start = (id) =&gt; { store[id] = new memwatch.HeapDiff() } const stop = (id) =&gt; { logger(id, store[id].end()) } const beforePrefetch = () =&gt; start('total') const requestStart = () =&gt; { store.init = store.total stop('init') } const beforeMiddleware = start const afterMiddleware = stop const beforeHandler = () =&gt; start('handler') const afterHandler = () =&gt; stop('handler') const requestEnd = () =&gt; stop('total') return { beforePrefetch, requestStart, beforeMiddleware, afterMiddleware, beforeHandler, afterHandler, requestEnd } } export const handler = middy(memoryPlugin()) .use(eventLogger()) .use(errorLogger()) .use(httpEventNormalizer()) .use(httpHeaderNormalizer()) .use(httpUrlencodePathParametersParser()) .use(httpUrlencodeBodyParser()) .use(httpJsonBodyParser()) .use(httpCors()) .use(httpSecurityHeaders()) .use(validator({eventSchema})) .handler(()=&gt;{}) await handler()  ","version":"Next","tagName":"h2"},{"title":"Alexa","type":0,"sectionRef":"#","url":"/docs/events/alexa","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Alexa","url":"/docs/events/alexa#aws-documentation","content":" Using AWS Lambda with Alexa  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Alexa","url":"/docs/events/alexa#example","content":" import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"API Gateway Authorizer","type":0,"sectionRef":"#","url":"/docs/events/api-gateway-authorizer","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"API Gateway Authorizer","url":"/docs/events/api-gateway-authorizer#aws-documentation","content":" Working with AWS Lambda authorizers for HTTP APIsInput to an Amazon API Gateway Lambda authorizer  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"API Gateway Authorizer","url":"/docs/events/api-gateway-authorizer#example","content":" import middy from '@middy/core' export const handler = middy().handler((event, context, { signal }) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"API Gateway (WebSocket)","type":0,"sectionRef":"#","url":"/docs/events/api-gateway-ws","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"API Gateway (WebSocket)","url":"/docs/events/api-gateway-ws#aws-documentation","content":" Using AWS Lambda with Amazon API GatewayWorking with WebSocket APIs  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"API Gateway (WebSocket)","url":"/docs/events/api-gateway-ws#example","content":" import middy from '@middy/core' import wsJsonBodyParserMiddleware from '@middy/ws-json-body-parser' import wsResponseMiddleware from '@middy/ws-response' import wsRouterHandler from '@middy/ws-router' import { handler as connectHandler } from './handlers/connect.js' import { handler as disconnectHandler } from './handlers/disconnect.js' import { handler as defaultHandler } from './handlers/default.js' const routes = [ { routeKey: '$connect', handler: connectHandler }, { routeKey: '$disconnect', handler: disconnectHandler }, { routeKey: 'default', handler: defaultHandler } ] export const handler = middy() .use(wsJsonBodyParserMiddleware()) .use(wsResponseMiddleware()) .handler(wsRouterHandler(routes))  ","version":"Next","tagName":"h2"},{"title":"API Gateway (HTTP)","type":0,"sectionRef":"#","url":"/docs/events/api-gateway-http","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"API Gateway (HTTP)","url":"/docs/events/api-gateway-http#aws-documentation","content":" Using AWS Lambda with Amazon API GatewayWorking with HTTP APIs  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"API Gateway (HTTP)","url":"/docs/events/api-gateway-http#example","content":" import middy from '@middy/core' import errorLoggerMiddleware from '@middy/error-logger' import inputOutputLoggerMiddleware from '@middy/input-output-logger' import httpContentNegotiationMiddleware from '@middy/http-content-negotiation' import httpContentEncodingMiddleware from '@middy/http-content-encoding' import httpCorsMiddleware from '@middy/http-cors' import httpErrorHandlerMiddleware from '@middy/http-error-handler' import httpEventNormalizerMiddleware from '@middy/http-event-normalizer' import httpHeaderNormalizerMiddleware from '@middy/http-header-normalizer' import httpJsonBodyParserMiddleware from '@middy/http-json-body-parser' import httpMultipartBodyParserMiddleware from '@middy/http-multipart-body-parser' import httpPartialResponseMiddleware from '@middy/http-partial-response' import httpResponseSerializerMiddleware from '@middy/http-response-serializer' import httpSecurityHeadersMiddleware from '@middy/http-security-headers' import httpUrlencodeBodyParserMiddleware from '@middy/http-urlencode-body-parser' import httpUrlencodePathParametersParserMiddleware from '@middy/http-urlencode-path-parser' import validatorMiddleware from 'validator' import warmupMiddleware from 'warmup' import eventSchema from './eventSchema.json' assert { type: 'json' } import responseSchema from './responseSchema.json' assert { type: 'json' } export const handler = middy({ timeoutEarlyResponse: () =&gt; { return { statusCode: 408 } } }) .use(warmupMiddleware()) .use(httpEventNormalizerMiddleware()) .use(httpHeaderNormalizerMiddleware()) .use( httpContentNegotiationMiddleware({ availableLanguages: ['en-CA', 'fr-CA'], availableMediaTypes: ['application/json'] }) ) .use(httpUrlencodePathParametersParserMiddleware()) // Start oneOf .use(httpUrlencodeBodyParserMiddleware()) .use(httpJsonBodyParserMiddleware()) .use(httpMultipartBodyParserMiddleware()) // End oneOf .use(httpSecurityHeadersMiddleware()) .use(httpCorsMiddleware()) .use(httpContentEncodingMiddleware()) .use( httpResponseSerializerMiddleware({ serializers: [ { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) } ], default: 'application/json' }) ) .use(httpPartialResponseMiddleware()) .use(validatorMiddleware({ eventSchema, responseSchema })) .use(httpErrorHandlerMiddleware()) .handler((event, context, { signal }) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"AppSync","type":0,"sectionRef":"#","url":"/docs/events/appsync","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"AppSync","url":"/docs/events/appsync#aws-documentation","content":" Using AWS Lambda with AppSync  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"AppSync","url":"/docs/events/appsync#example","content":" import middy from '@middy/core' export const handler = middy().handler((event, context, { signal }) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"API Gateway (REST)","type":0,"sectionRef":"#","url":"/docs/events/api-gateway-rest","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"API Gateway (REST)","url":"/docs/events/api-gateway-rest#aws-documentation","content":" Using AWS Lambda with Amazon API GatewayWorking with REST APIs  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"API Gateway (REST)","url":"/docs/events/api-gateway-rest#example","content":" import middy from '@middy/core' import errorLoggerMiddleware from '@middy/error-logger' import inputOutputLoggerMiddleware from '@middy/input-output-logger' import httpContentNegotiationMiddleware from '@middy/http-content-negotiation' import httpContentEncodingMiddleware from '@middy/http-content-encoding' import httpCorsMiddleware from '@middy/http-cors' import httpErrorHandlerMiddleware from '@middy/http-error-handler' import httpEventNormalizerMiddleware from '@middy/http-event-normalizer' import httpHeaderNormalizerMiddleware from '@middy/http-header-normalizer' import httpJsonBodyParserMiddleware from '@middy/http-json-body-parser' import httpMultipartBodyParserMiddleware from '@middy/http-multipart-body-parser' import httpPartialResponseMiddleware from '@middy/http-partial-response' import httpResponseSerializerMiddleware from '@middy/http-response-serializer' import httpSecurityHeadersMiddleware from '@middy/http-security-headers' import httpUrlencodeBodyParserMiddleware from '@middy/http-urlencode-body-parser' import httpUrlencodePathParametersParserMiddleware from '@middy/http-urlencode-path-parser' import validatorMiddleware from 'validator' import warmupMiddleware from 'warmup' import eventSchema from './eventSchema.json' assert { type: 'json' } import responseSchema from './responseSchema.json' assert { type: 'json' } export const handler = middy({ timeoutEarlyResponse: () =&gt; { return { statusCode: 408 } } }) .use(warmupMiddleware()) .use(httpEventNormalizerMiddleware()) .use(httpHeaderNormalizerMiddleware()) .use( httpContentNegotiationMiddleware({ availableLanguages: ['en-CA', 'fr-CA'], availableMediaTypes: ['application/json'] }) ) .use(httpUrlencodePathParametersParserMiddleware()) // Start oneOf .use(httpUrlencodeBodyParserMiddleware()) .use(httpJsonBodyParserMiddleware()) .use(httpMultipartBodyParserMiddleware()) // End oneOf .use(httpSecurityHeadersMiddleware()) .use(httpCorsMiddleware()) .use(httpContentEncodingMiddleware()) .use( httpResponseSerializerMiddleware({ serializers: [ { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) } ], defaultContentType: 'application/json' }) ) .use(httpPartialResponseMiddleware()) .use(validatorMiddleware({ eventSchema, responseSchema })) .use(httpErrorHandlerMiddleware()) .handler((event, context, { signal }) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Application Load Balancer","type":0,"sectionRef":"#","url":"/docs/events/application-load-balancer","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Application Load Balancer","url":"/docs/events/application-load-balancer#aws-documentation","content":" Using AWS Lambda with an Application Load Balancer  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Application Load Balancer","url":"/docs/events/application-load-balancer#example","content":" import middy from '@middy/core' import httpRouterHandler from '@middy/http-router' import errorLoggerMiddleware from '@middy/error-logger' import inputOutputLoggerMiddleware from '@middy/input-output-logger' import httpContentNegotiationMiddleware from '@middy/http-content-negotiation' import httpContentEncodingMiddleware from '@middy/http-content-encoding' import httpCorsMiddleware from '@middy/http-cors' import httpErrorHandlerMiddleware from '@middy/http-error-handler' import httpEventNormalizerMiddleware from '@middy/http-event-normalizer' import httpHeaderNormalizerMiddleware from '@middy/http-header-normalizer' import httpJsonBodyParserMiddleware from '@middy/http-json-body-parser' import httpMultipartBodyParserMiddleware from '@middy/http-multipart-body-parser' import httpPartialResponseMiddleware from '@middy/http-partial-response' import httpResponseSerializerMiddleware from '@middy/http-response-serializer' import httpSecurityHeadersMiddleware from '@middy/http-security-headers' import httpUrlencodeBodyParserMiddleware from '@middy/http-urlencode-body-parser' import httpUrlencodePathParametersParserMiddleware from '@middy/http-urlencode-path-parser' import warmupMiddleware from 'warmup' import { handler as getHandler } from './handlers/get-user.js' import { handler as postHandler } from './handlers/get-user.js' const routes = [ { method: 'GET', path: '/user/{id}', handler: getHandler }, { method: 'POST', path: '/user', handler: postHandler } ] export const handler = middy({ timeoutEarlyResponse: () =&gt; { return { statusCode: 408 } } }) .use(warmupMiddleware()) .use(httpEventNormalizerMiddleware()) .use(httpHeaderNormalizerMiddleware()) .use( httpContentNegotiationMiddleware({ availableLanguages: ['en-CA', 'fr-CA'], availableMediaTypes: ['application/json'] }) ) .use(httpUrlencodePathParametersParserMiddleware()) // Start oneOf .use(httpUrlencodeBodyParserMiddleware()) .use(httpJsonBodyParserMiddleware()) .use(httpMultipartBodyParserMiddleware()) // End oneOf .use(httpSecurityHeadersMiddleware()) .use(httpCorsMiddleware()) .use(httpContentEncodingMiddleware()) .use( httpResponseSerializerMiddleware({ serializers: [ { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) } ], default: 'application/json' }) ) .use(httpPartialResponseMiddleware()) .use(httpErrorHandlerMiddleware()) .handler(httpRouterHandler(routes))  ","version":"Next","tagName":"h2"},{"title":"CloudFormation","type":0,"sectionRef":"#","url":"/docs/events/cloud-formation","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"CloudFormation","url":"/docs/events/cloud-formation#aws-documentation","content":" Using AWS Lambda with AWS CloudFormation  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"CloudFormation","url":"/docs/events/cloud-formation#example","content":" import middy from '@middy/core' import cloudformationRouterHandler from '@middy/cloudformation-router' import cloudformationResponseMiddleware from '@middy/cloudformation-response' import validatorMiddleware from '@middy/validator' const createHandler = middy() .use(validatorMiddleware({eventSchema: {...} })) .handler((event, context) =&gt; { return { PhysicalResourceId: '...', Data:{} } }) const updateHandler = middy() .use(validatorMiddleware({eventSchema: {...} })) .handler((event, context) =&gt; { return { PhysicalResourceId: '...', Data: {} } }) const deleteHandler = middy() .use(validatorMiddleware({eventSchema: {...} })) .handler((event, context) =&gt; { return { PhysicalResourceId: '...' } }) const routes = [ { requesType: 'Create', handler: createHandler }, { requesType: 'Update', handler: updateHandler }, { routeKey: 'Delete', handler: deleteHandler } ] export const handler = middy() .use(cloudformationResponseMiddleware()) .handler(cloudformationRouterHandler(routes))  ","version":"Next","tagName":"h2"},{"title":"CloudFront Lambda@Edge","type":0,"sectionRef":"#","url":"/docs/events/cloud-front","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"CloudFront Lambda@Edge","url":"/docs/events/cloud-front#aws-documentation","content":" Using AWS Lambda with CloudFront Lambda@Edge  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"CloudFront Lambda@Edge","url":"/docs/events/cloud-front#example","content":" import middy from '@middy/core' export const handler = middy() //.use(cfHeaderNormalizer()) // Let use know if this would have value .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"CloudTrail","type":0,"sectionRef":"#","url":"/docs/events/cloud-trail","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"CloudTrail","url":"/docs/events/cloud-trail#aws-documentation","content":" Using AWS Lambda with AWS CloudTrail  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"CloudTrail","url":"/docs/events/cloud-trail#example","content":" import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"CloudWatch Alarm","type":0,"sectionRef":"#","url":"/docs/events/cloud-watch-alarm","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"CloudWatch Alarm","url":"/docs/events/cloud-watch-alarm#aws-documentation","content":" Using AWS Lambda with CloudWatch Alarm  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"CloudWatch Alarm","url":"/docs/events/cloud-watch-alarm#example","content":" import middy from '@middy/core' export const handler = middy().handler((event, context, { signal }) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"CodePipeline","type":0,"sectionRef":"#","url":"/docs/events/code-pipeline","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"CodePipeline","url":"/docs/events/code-pipeline#aws-documentation","content":" Using AWS Lambda with AWS CodePipeline  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"CodePipeline","url":"/docs/events/code-pipeline#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"CloudWatch Logs","type":0,"sectionRef":"#","url":"/docs/events/cloud-watch-logs","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"CloudWatch Logs","url":"/docs/events/cloud-watch-logs#aws-documentation","content":" Using Lambda with CloudWatch Logs  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"CloudWatch Logs","url":"/docs/events/cloud-watch-logs#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, { signal }) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Code Commit","type":0,"sectionRef":"#","url":"/docs/events/code-commit","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Code Commit","url":"/docs/events/code-commit#aws-documentation","content":" Using AWS Lambda with AWS CodeCommit  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Code Commit","url":"/docs/events/code-commit#example","content":" import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Cognito","type":0,"sectionRef":"#","url":"/docs/events/cognito","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Cognito","url":"/docs/events/cognito#aws-documentation","content":" Using AWS Lambda with Amazon Cognito  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Cognito","url":"/docs/events/cognito#example","content":" import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Config","type":0,"sectionRef":"#","url":"/docs/events/config","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Config","url":"/docs/events/config#aws-documentation","content":" Using AWS Lambda with AWS Config  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Config","url":"/docs/events/config#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"DynamoDB","type":0,"sectionRef":"#","url":"/docs/events/dynamodb","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"DynamoDB","url":"/docs/events/dynamodb#aws-documentation","content":" Using AWS Lambda with Amazon DynamoDB  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"DynamoDB","url":"/docs/events/dynamodb#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Connect","type":0,"sectionRef":"#","url":"/docs/events/connect","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Connect","url":"/docs/events/connect#aws-documentation","content":" Using Lambda with Amazon Connect  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Connect","url":"/docs/events/connect#example","content":" import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"DocumentDB","type":0,"sectionRef":"#","url":"/docs/events/documentdb","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"DocumentDB","url":"/docs/events/documentdb#aws-documentation","content":" Using AWS Lambda with Amazon DocumentDB  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"DocumentDB","url":"/docs/events/documentdb#example","content":" import middy from '@middy/core' export const handler = middy().handler((event, context, { signal }) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"EC2","type":0,"sectionRef":"#","url":"/docs/events/ec2","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"EC2","url":"/docs/events/ec2#aws-documentation","content":" Using AWS Lambda with Amazon EC2  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"EC2","url":"/docs/events/ec2#example","content":" import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"EventBridge","type":0,"sectionRef":"#","url":"/docs/events/event-bridge","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"EventBridge","url":"/docs/events/event-bridge#aws-documentation","content":" Using AWS Lambda with Amazon EventBridge (CloudWatch Events)  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"EventBridge","url":"/docs/events/event-bridge#example","content":" import middy from '@middy/core' export const handler = middy().handler((event, context, { signal }) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Internet of things (IoT)","type":0,"sectionRef":"#","url":"/docs/events/iot","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Internet of things (IoT)","url":"/docs/events/iot#aws-documentation","content":" Using AWS Lambda with AWS IoT  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Internet of things (IoT)","url":"/docs/events/iot#example","content":" import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"IoT Events","type":0,"sectionRef":"#","url":"/docs/events/iot-events","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"IoT Events","url":"/docs/events/iot-events#aws-documentation","content":" Using AWS Lambda with AWS IoT Events  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"IoT Events","url":"/docs/events/iot-events#example","content":" import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Function URL","type":0,"sectionRef":"#","url":"/docs/events/function-url","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Function URL","url":"/docs/events/function-url#aws-documentation","content":" Using AWS Lambda with Amazon API GatewayWorking with HTTP APIs  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Function URL","url":"/docs/events/function-url#example","content":" import middy from '@middy/core' import errorLoggerMiddleware from '@middy/error-logger' import inputOutputLoggerMiddleware from '@middy/input-output-logger' import httpContentNegotiationMiddleware from '@middy/http-content-negotiation' import httpContentEncodingMiddleware from '@middy/http-content-encoding' import httpCorsMiddleware from '@middy/http-cors' import httpErrorHandlerMiddleware from '@middy/http-error-handler' import httpEventNormalizerMiddleware from '@middy/http-event-normalizer' import httpHeaderNormalizerMiddleware from '@middy/http-header-normalizer' import httpJsonBodyParserMiddleware from '@middy/http-json-body-parser' import httpMultipartBodyParserMiddleware from '@middy/http-multipart-body-parser' import httpPartialResponseMiddleware from '@middy/http-partial-response' import httpResponseSerializerMiddleware from '@middy/http-response-serializer' import httpSecurityHeadersMiddleware from '@middy/http-security-headers' import httpUrlencodeBodyParserMiddleware from '@middy/http-urlencode-body-parser' import httpUrlencodePathParametersParserMiddleware from '@middy/http-urlencode-path-parser' import validatorMiddleware from 'validator' import warmupMiddleware from 'warmup' import eventSchema from './eventSchema.json' assert { type: 'json' } import responseSchema from './responseSchema.json' assert { type: 'json' } export const handler = middy({ timeoutEarlyResponse: () =&gt; { return { statusCode: 408 } }, streamifyResponse: true }) .use(warmupMiddleware()) .use(httpEventNormalizerMiddleware()) .use(httpHeaderNormalizerMiddleware()) .use( httpContentNegotiationMiddleware({ availableLanguages: ['en-CA', 'fr-CA'], availableMediaTypes: ['application/json'] }) ) .use(httpUrlencodePathParametersParserMiddleware()) // Start oneOf .use(httpUrlencodeBodyParserMiddleware()) .use(httpJsonBodyParserMiddleware()) .use(httpMultipartBodyParserMiddleware()) // End oneOf .use(httpSecurityHeadersMiddleware()) .use(httpCorsMiddleware()) .use(httpContentEncodingMiddleware()) .use( httpResponseSerializerMiddleware({ serializers: [ { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) } ], default: 'application/json' }) ) .use(httpPartialResponseMiddleware()) .use(validatorMiddleware({ eventSchema, responseSchema })) .use(httpErrorHandlerMiddleware()) .handler((event, context, { signal }) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Kafka, Managed Streaming (MSK)","type":0,"sectionRef":"#","url":"/docs/events/kafka-managed-streaming","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Kafka, Managed Streaming (MSK)","url":"/docs/events/kafka-managed-streaming#aws-documentation","content":" Using Lambda with Amazon MSK  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Kafka, Managed Streaming (MSK)","url":"/docs/events/kafka-managed-streaming#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Kafka, Self-Managed","type":0,"sectionRef":"#","url":"/docs/events/kafka-self-managed","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Kafka, Self-Managed","url":"/docs/events/kafka-self-managed#aws-documentation","content":" Using Lambda with self-managed Apache Kafka  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Kafka, Self-Managed","url":"/docs/events/kafka-self-managed#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Kinesis Firehose","type":0,"sectionRef":"#","url":"/docs/events/kinesis-firehose","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Kinesis Firehose","url":"/docs/events/kinesis-firehose#aws-documentation","content":" Using AWS Lambda with Amazon Kinesis Data Firehose  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Kinesis Firehose","url":"/docs/events/kinesis-firehose#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Lex","type":0,"sectionRef":"#","url":"/docs/events/lex","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Lex","url":"/docs/events/lex#aws-documentation","content":" Using AWS Lambda with Amazon LexUsing an AWS Lambda function with Amazon Lex V2  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Lex","url":"/docs/events/lex#example","content":" import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Kinesis Streams","type":0,"sectionRef":"#","url":"/docs/events/kinesis-streams","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Kinesis Streams","url":"/docs/events/kinesis-streams#aws-documentation","content":" Using AWS Lambda with Amazon Kinesis  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Kinesis Streams","url":"/docs/events/kinesis-streams#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"All AWS Events","type":0,"sectionRef":"#","url":"/docs/events/intro","content":"","keywords":"","version":"Next"},{"title":"Middlewares that can benefit any Lambda​","type":1,"pageTitle":"All AWS Events","url":"/docs/events/intro#middlewares-that-can-benefit-any-lambda","content":" import middy from '@middy/core' import cloudWatchMetricsMiddleware from '@middy/cloudwatch-metrics' import errorLoggerMiddleware from '@middy/error-logger' import inputOutputLoggerMiddleware from '@middy/input-output-logger' import validatorMiddleware from 'validator' import warmupMiddleware from 'warmup' import eventSchema from './eventSchema.json' assert { type: 'json' } import responseSchema from './responseSchema.json' assert { type: 'json' } const handler = middy() .use(warmupMiddleware()) .use(cloudWatchMetricsMiddleware()) .use(inputOutputLoggerMiddleware()) .use(errorLoggerMiddleware()) .use(validatorMiddleware({ eventSchema, responseSchema })) .handler(async (event, context, { signal }) =&gt; { // ... })   ","version":"Next","tagName":"h2"},{"title":"Need secrets? We have you covered there too​","type":1,"pageTitle":"All AWS Events","url":"/docs/events/intro#need-secrets-we-have-you-covered-there-too","content":" import middy from '@middy/core' import { getInternal } from '@middy/util' import rdsSignerMiddleware from '@middy/rds-signer' import secretsManagerMiddleware from '@middy/secrets-manager' import ssmMiddleware from '@middy/ssm' import stsMiddleware from '@middy/sts' export const handler = middy() .use( rdsSignerMiddleware({ fetchData: { rdsSigner: { region: process.env.AWS_REGION, hostname: process.env.RDS_HOSTNAME, username: 'iam_role', port: 5555 } } }) ) .use( secretsManagerMiddleware({ fetchData: { secretsManager: '/dev/service_name/key_name' } }) ) .use( ssmMiddleware({ fetchData: { ssm: '/dev/service_name/key_name' } }) ) .use( stsMiddleware({ fetchData: { sts: { RoleArn: '.../role' } } }) ) .before(async (request) =&gt; { request.context.secrets = await getInternal(true, request) }) .handler(async (event, context, { signal }) =&gt; { // context.secrets = { rdsSigner, secretsManager, ssm, sts } })   ","version":"Next","tagName":"h2"},{"title":"How about configs? We have you covered there as well​","type":1,"pageTitle":"All AWS Events","url":"/docs/events/intro#how-about-configs-we-have-you-covered-there-as-well","content":" import middy from '@middy/core' import { getInternal } from '@middy/util' import appConfigMiddleware from '@middy/appconfig' import s3Middleware from '@middy/s3' import dynamoDBMiddleware from '@middy/dynamodb' import ssmMiddleware from '@middy/ssm' export const handler = middy() .use( appConfigMiddleware({ fetchData: { appConfig: { Application: '...', ClientId: '...', Configuration: '...', Environment: '...' } } }) ) .use( s3Middleware({ fetchData: { s3: { Bucket: '...', Key: '...' } } }) ) .use( dynamoDBMiddleware({ fetchData: { dynamodb: { TableName: '...', Key: { '...' } } } }) ) .use( ssmMiddleware({ fetchData: { ssm: '/dev/service_name/key_name' } }) ) .before(async (request) =&gt; { request.context.configs = await getInternal(true, request) }) .handler(async (event, context, { signal }) =&gt; { // context.configs = { appConfig, dynamodb, s3, ssm } })  ","version":"Next","tagName":"h2"},{"title":"RDS","type":0,"sectionRef":"#","url":"/docs/events/rds","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"RDS","url":"/docs/events/rds#aws-documentation","content":" Using AWS Lambda with Amazon RDS  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"RDS","url":"/docs/events/rds#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) // RDS -&gt; SNS -&gt; Lambda .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"S3 Batch","type":0,"sectionRef":"#","url":"/docs/events/s3-batch","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"S3 Batch","url":"/docs/events/s3-batch#aws-documentation","content":" Using AWS Lambda with Amazon S3 batch operations  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"S3 Batch","url":"/docs/events/s3-batch#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"S3","type":0,"sectionRef":"#","url":"/docs/events/s3","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"S3","url":"/docs/events/s3#aws-documentation","content":" Using AWS Lambda with Amazon S3  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"S3","url":"/docs/events/s3#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) // S3 -&gt; SNS -&gt; SQS -&gt; Lambda .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"MQ","type":0,"sectionRef":"#","url":"/docs/events/mq","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"MQ","url":"/docs/events/mq#aws-documentation","content":" Using Lambda with Amazon MQ  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"MQ","url":"/docs/events/mq#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Secrets Manager","type":0,"sectionRef":"#","url":"/docs/events/secrets-manager","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"Secrets Manager","url":"/docs/events/secrets-manager#aws-documentation","content":" Using AWS Lambda with Secrets Manager  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Secrets Manager","url":"/docs/events/secrets-manager#example","content":" import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"S3 Object","type":0,"sectionRef":"#","url":"/docs/events/s3-object","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"S3 Object","url":"/docs/events/s3-object#aws-documentation","content":" Transforming S3 Objects with S3 Object LambdaTransforming objects with S3 Object Lambda  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"S3 Object","url":"/docs/events/s3-object#example","content":" import middy from '@middy/core' import s3ObjectResponseMiddleware from '@middy/s3-object-response' import {captureAWSv3Client} from 'aws-xray-sdk-core' import {captureFetchGlobal} from 'aws-xray-sdk-fetch' captureFetchGlobal() export const handler = middy() .use(s3ObjectResponseMiddleware({ awsClientCapture: captureAWSv3Client, bodyType: 'promise' })) .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"SQS","type":0,"sectionRef":"#","url":"/docs/events/sqs","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"SQS","url":"/docs/events/sqs#aws-documentation","content":" Using AWS Lambda with Amazon SQS  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"SQS","url":"/docs/events/sqs#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' import sqsPartialBatchFailure from '@middy/sqs-partial-batch-failure' export const handler = middy() .use(eventNormalizerMiddleware()) .use(sqsPartialBatchFailure()) .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"SES","type":0,"sectionRef":"#","url":"/docs/events/ses","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"SES","url":"/docs/events/ses#aws-documentation","content":" Using AWS Lambda with Amazon SES  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"SES","url":"/docs/events/ses#example","content":" import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/docs/faq","content":"","keywords":"","version":"Next"},{"title":"My lambda keep timing out without responding, what do I do?​","type":1,"pageTitle":"FAQ","url":"/docs/faq#my-lambda-keep-timing-out-without-responding-what-do-i-do","content":" Likely your event loop is not empty. This happens when you have a database connect still open for example. Checkout @middy/do-not-wait-for-empty-event-loop. ","version":"Next","tagName":"h3"},{"title":"SNS","type":0,"sectionRef":"#","url":"/docs/events/sns","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"SNS","url":"/docs/events/sns#aws-documentation","content":" Using AWS Lambda with Amazon SNS  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"SNS","url":"/docs/events/sns#example","content":" import middy from '@middy/core' import eventNormalizerMiddleware from '@middy/event-normalizer' export const handler = middy() .use(eventNormalizerMiddleware()) .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"VPC Lattice","type":0,"sectionRef":"#","url":"/docs/events/vpc-lattice","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"VPC Lattice","url":"/docs/events/vpc-lattice#aws-documentation","content":" Using AWS Lambda with Amazon VPC Lattice  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"VPC Lattice","url":"/docs/events/vpc-lattice#example","content":" import middy from '@middy/core' import errorLoggerMiddleware from '@middy/error-logger' import inputOutputLoggerMiddleware from '@middy/input-output-logger' import httpContentNegotiationMiddleware from '@middy/http-content-negotiation' import httpContentEncodingMiddleware from '@middy/http-content-encoding' import httpCorsMiddleware from '@middy/http-cors' import httpErrorHandlerMiddleware from '@middy/http-error-handler' import httpEventNormalizerMiddleware from '@middy/http-event-normalizer' // required import httpHeaderNormalizerMiddleware from '@middy/http-header-normalizer' import httpJsonBodyParserMiddleware from '@middy/http-json-body-parser' import httpMultipartBodyParserMiddleware from '@middy/http-multipart-body-parser' import httpPartialResponseMiddleware from '@middy/http-partial-response' import httpResponseSerializerMiddleware from '@middy/http-response-serializer' import httpSecurityHeadersMiddleware from '@middy/http-security-headers' import httpUrlencodeBodyParserMiddleware from '@middy/http-urlencode-body-parser' import httpUrlencodePathParametersParserMiddleware from '@middy/http-urlencode-path-parser' import validatorMiddleware from 'validator' import warmupMiddleware from 'warmup' import eventSchema from './eventSchema.json' assert { type: 'json' } import responseSchema from './responseSchema.json' assert { type: 'json' } export const handler = middy({ timeoutEarlyResponse: () =&gt; { return { statusCode: 408 } } }) .use(warmupMiddleware()) .use(httpEventNormalizerMiddleware()) .use(httpHeaderNormalizerMiddleware()) .use( httpContentNegotiationMiddleware({ availableLanguages: ['en-CA', 'fr-CA'], availableMediaTypes: ['application/json'] }) ) .use(httpUrlencodePathParametersParserMiddleware()) // Start oneOf .use(httpUrlencodeBodyParserMiddleware()) .use(httpJsonBodyParserMiddleware()) .use(httpMultipartBodyParserMiddleware()) // End oneOf .use(httpSecurityHeadersMiddleware()) .use(httpCorsMiddleware()) .use(httpContentEncodingMiddleware()) .use( httpResponseSerializerMiddleware({ serializers: [ { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) } ], default: 'application/json' }) ) .use(httpPartialResponseMiddleware()) .use(validatorMiddleware({ eventSchema, responseSchema })) .use(httpErrorHandlerMiddleware()) .handler((event, context, { signal }) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"WorkMail","type":0,"sectionRef":"#","url":"/docs/events/workmail","content":"","keywords":"","version":"Next"},{"title":"AWS Documentation​","type":1,"pageTitle":"WorkMail","url":"/docs/events/workmail#aws-documentation","content":" Configuring AWS Lambda for Amazon WorkMail  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"WorkMail","url":"/docs/events/workmail#example","content":" import middy from '@middy/core' export const handler = middy() .handler((event, context, {signal}) =&gt; { // ... })  ","version":"Next","tagName":"h2"},{"title":"Integrations","type":0,"sectionRef":"#","url":"/docs/integrations/intro","content":"Integrations caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":"","version":"Next"},{"title":"Apollo Server","type":0,"sectionRef":"#","url":"/docs/integrations/apollo-server","content":"Apollo Server caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub. import middy from '@middy/core' import { ApolloServer, gql } from 'apollo-server-lambda' import { buildFederatedSchema } from '@apollo/federation' import { resolvers } from './graphql/resolvers.js' import { graphqlFileToStr } from './graphql/schema.js' const graphQL = new ApolloServer({ schema: buildFederatedSchema({ typeDefs: gql(graphqlFileToStr), resolvers }) }) // Do not use: `@middy/http-json-body-parser` it is already handled within apollo export const handler = middy().handler(graphQL.createHandler()) ","keywords":"","version":"Next"},{"title":"Pino","type":0,"sectionRef":"#","url":"/docs/integrations/pino","content":"Pino caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":"","version":"Next"},{"title":"Serverless Framework","type":0,"sectionRef":"#","url":"/docs/integrations/serverless-framework","content":"Serverless Framework caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub. TODO comment about serverless-warmup","keywords":"","version":"Next"},{"title":"AWS Relational Database Service (RDS)","type":0,"sectionRef":"#","url":"/docs/integrations/RDS","content":"AWS Relational Database Service (RDS) caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub. First, you need to pass in a password. In order from most secure to least: RDS.Signer, SecretsManager, SSM using SecureString.SSM can be considered equally secure to SecretsManager if you have your own password rotation system. Additionally, you will want to verify the RDS certificate and the domain of your connection. You can use this sudo code to get you started: import tls from 'tls' // https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html const ca = `-----BEGIN CERTIFICATE----- ...` connectionOptions = { ..., ssl: { rejectUnauthorized: true, ca, checkServerIdentity: (host, cert) =&gt; { const error = tls.checkServerIdentity(host, cert) if ( error &amp;&amp; !cert.subject.CN.endsWith('.rds.amazonaws.com') ) { return error } } } } Corresponding RDS.ParameterGroups values should be set to enforce TLS connections.","keywords":"","version":"Next"},{"title":"Serverless Stack","type":0,"sectionRef":"#","url":"/docs/integrations/serverless-stack","content":"Serverless Stack caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":"","version":"Next"},{"title":"Contributing","type":0,"sectionRef":"#","url":"/docs/intro/contributing","content":"Contributing In the spirit of Open Source Software, everyone is very welcome to contribute to this repository. Feel free to raise issues or to submit Pull Requests. Before contributing to the project, make sure to have a look at our Code of Conduct.","keywords":"","version":"Next"},{"title":"Handling Errors","type":0,"sectionRef":"#","url":"/docs/intro/handling-errors","content":"Handling Errors But, what happens when there is an error? When there is an error, the regular control flow is stopped and the execution is moved back to all the middlewares that implemented a special phase called onError, following the same order as after. Every onError middleware can decide to handle the error and create a proper response or to delegate the error to the next middleware. When a middleware handles the error and creates a response, the execution is still propagated to all the other error middlewares and they have a chance to update or replace the response as needed. At the end of the error middlewares sequence, the response is returned to the user. If no middleware manages the error, the Lambda execution fails reporting the unmanaged error. // Initialize response request.response = request.response ?? {} // Add to response request.response.add = 'more' // Override an error request.error = new Error('...') // handle the error return request.response ","keywords":"","version":"Next"},{"title":"Early Response","type":0,"sectionRef":"#","url":"/docs/intro/early-interrupt","content":"Early Response Some middlewares might need to stop the whole execution flow and return a response immediately. Note: this will totally stop the execution of successive middlewares in any phase (before, after, onError) and returns an early response (or an error) directly at the Lambda level. If your middlewares do a specific task on every request like output serialization, error handling or clean, these won't be invoked in this case. They will have to be handled before the return. In this example, we can use this capability for building a sample caching middleware: // some function that calculates the cache id based on the current event const calculateCacheId = (event) =&gt; { /* ... */ } const storage = {} // middleware const cacheMiddleware = (options) =&gt; { let cacheKey const cacheMiddlewareBefore = async (request) =&gt; { cacheKey = options.calculateCacheId(request.event) if (Object.hasOwnProperty.call(options.storage, cacheKey)) { // if the value can be `undefined` use this line request.earlyResponse = options.storage[cacheKey] // exits early and returns the value from the cache if it's already there return options.storage[cacheKey] } } const cacheMiddlewareAfter = async (request) =&gt; { // stores the calculated response in the cache options.storage[cacheKey] = request.response } const cacheMiddlewareOnError = async (request) =&gt; { // Note: onError cannot earlyResonse with undefined } return { before: cacheMiddlewareBefore, after: cacheMiddlewareAfter } } // sample usage const lambdaHandler = (event, context) =&gt; { /* ... */ } export const handler = middy() .use( cacheMiddleware({ calculateCacheId, storage }) ) .handler(lambdaHandler) ","keywords":"","version":"Next"},{"title":"Getting started","type":0,"sectionRef":"#","url":"/docs/intro/getting-started","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"Getting started","url":"/docs/intro/getting-started#install","content":" To install middy, you can use NPM:  npmYarnpnpmBun npm install --save @middy/core   If you are using TypeScript, you will also want to make sure that you have installed the @types/aws-lambda peer-dependency:  npmYarnpnpmBun npm install --save-dev @types/aws-lambda   ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Getting started","url":"/docs/intro/getting-started#usage","content":" As you will see in the next example, using middy is very simple and requires just few steps:  Write your Lambda handlers as usual, focusing mostly on implementing the bare business logic for them.Import middy and all the middlewares you want to use.Wrap your handler in the middy() factory function. This will return a new enhanced instance of your original handler, to which you will be able to attach the middlewares you need.Attach all the middlewares you need using the function .use(somemiddleware())  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Getting started","url":"/docs/intro/getting-started#example","content":" import middy from '@middy/core' import middleware1 from 'sample-middleware1' import middleware2 from 'sample-middleware2' import middleware3 from 'sample-middleware3' const lambdaHandler = (event, context) =&gt; { /* your business logic */ } export const handler = middy() .use(middleware1()) .use(middleware2()) .use(middleware3()) .handler(lambdaHandler)   .use() takes a single middleware or an array of middlewares, so you can attach multiple middlewares in a single call:  import middy from '@middy/core' import middleware1 from 'sample-middleware1' import middleware2 from 'sample-middleware2' import middleware3 from 'sample-middleware3' const lambdaHandler = (event, context) =&gt; { /* your business logic */ } export const handler = middy() .use([middleware1(), middleware2(), middleware3()]) .handler(lambdaHandler)   You can also attach inline middlewares by using the functions .before, .after and .onError.  For a more detailed use case and examples check the Writing a middleware section. ","version":"Next","tagName":"h2"},{"title":"Powertools for AWS Lambda","type":0,"sectionRef":"#","url":"/docs/integrations/lambda-powertools","content":"","keywords":"","version":"Next"},{"title":"Intro​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#intro","content":" Powertools is a collection of utilities that can be used independently or together to help you build production-ready serverless applications. Currently, Powertools provides the following utilities that are compatible with Middy:  Logger - Structured logging made easier with a middleware to capture key fields from the Lambda context, cold starts, and more. Compatible with Amazon CloudWatch, Datadog, and more.Tracer - An opinionated wrapper around AWS X-Ray SDK for Node.js with a middleware to automatically capture traces for function invocations, HTTP requests, and AWS SDK calls, and more.Metrics - Create Amazon CloudWatch custom metrics asynchronously with a middleware that takes care of capturing cold starts, and flushes metrics to CloudWatch in EMF-formatted batches.Idempotency - Middleware to make your Lambda functions idempotent and prevent duplicate execution based on payload content.Parser - Data validation and parsing using Zod, a TypeScript-first schema declaration and validation library.  Powertools also provides other utilities that can be used independently of Middy:  Parameters - Handle partial failures when processing batches of records from Amazon SQS, Amazon Kinesis Data Streams, and Amazon DynamoDB Streams.Batch Processing - Handle partial failures when processing batches of records from Amazon SQS, Amazon Kinesis Data Streams, and Amazon DynamoDB Streams.  ","version":"Next","tagName":"h2"},{"title":"Logger​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#logger","content":" Key features:  Capturing key fields from the Lambda context, cold starts, and structure logging output as JSON.Logging Lambda invocation events when instructed (disabled by default).Printing all the logs only for a percentage of invocations via log sampling (disabled by default).Appending additional keys to structured logs at any point in time.Providing a custom log formatter (Bring Your Own Formatter) to output logs in a structure compatible with your organization’s Logging RFC.  ","version":"Next","tagName":"h2"},{"title":"Install​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#install","content":" npmYarnpnpmBun npm install --save @aws-lambda-powertools/logger   ","version":"Next","tagName":"h3"},{"title":"Options​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#options","content":" Class constructor accepts the following options, which are all optional:  logLevel (string|LogLevel): Log level to use. Defaults to INFO, but you can use any of the following values: SILENT, DEBUG, INFO, WARN, ERROR, CRITICAL.serviceName (string): Service name to use that will be used in all log statements. Defaults to service_undefined.sampleRateValue (number): number between 0.0 and 1 to determine the sample rate for debug logging. Defaults to 0 (no debub logging).  Middleware accepts the following options:  logger (Logger) (required): An instance of the Logger class.option (object) (optional): An object with the following keys: logEvent (boolean) (optional): Whether to log the Lambda invocation event. Defaults to false.clearState (boolean) (optional): Whether to clear the logger state after each invocation. Defaults to false.  ","version":"Next","tagName":"h3"},{"title":"Sample usage​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#sample-usage","content":" import middy from '@middy/core'; import { Logger } from '@aws-lambda-powertools/logger'; import { injectLambdaContext } from '@aws-lambda-powertools/logger/middleware'; const logger = new Logger({ serviceName: 'serverlessAirline' }); const lambdaHandler = async (event, context) =&gt; { logger.info('This is an INFO log with some context', { foo: { bar: 'baz' } }); }; export const handler = middy(lambdaHandler) .use(injectLambdaContext(logger));   The above code will output the following log:  { &quot;cold_start&quot;: true, &quot;function_arn&quot;: &quot;arn:aws:lambda:eu-west-1:123456789012:function:shopping-cart-api-lambda-prod-eu-west-1&quot;, &quot;function_memory_size&quot;: 128, &quot;function_request_id&quot;: &quot;c6af9ac6-7b61-11e6-9a41-93e812345678&quot;, &quot;function_name&quot;: &quot;shopping-cart-api-lambda-prod-eu-west-1&quot;, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;This is an INFO log with some context&quot;, &quot;foo&quot;: { &quot;bar&quot;: &quot;baz&quot; }, &quot;service&quot;: &quot;serverlessAirline&quot;, &quot;timestamp&quot;: &quot;2021-12-12T21:21:08.921Z&quot;, &quot;xray_trace_id&quot;: &quot;abcdef123456abcdef123456abcdef123456&quot; }   As you can see, the log entry includes several fields that are automatically captured by the Logger utility, and that can help you better understand the context of the log entry. For example, the cold_start field indicates whether the Lambda function was cold started or not, and the xray_trace_id field contains the AWS X-Ray trace ID for the Lambda invocation. This is useful when you're troubleshooting a problem and want to correlate the logs with the traces.  The Logger utility also allows you to append arbitary keys to the log entry at both the global level, at the invocation level, and at the single log level. For example, there might be some keys that you want to include in all log entries, such as the environment key to differentiate between the prod and dev environments, or in other cases you might want to include some keys only for a specific log entry, such as the customer_id key to identify the customer that triggered the Lambda invocation.  Additionally, you can also configure Logger to log the Lambda invocation event, which can be useful when you're troubleshooting a problem and want to see the event that triggered the Lambda invocation. Finally, Logger allows you to define a custom log formatter to output logs in a different JSON structure from the default one. This is useful when you want to output logs in a structure that is compatible with your organization's requirements.  ","version":"Next","tagName":"h3"},{"title":"Tracer​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#tracer","content":" Key features:  Auto-capturing cold start and service name as annotations, and responses or full exceptions as metadata.Automatically tracing HTTP(S) clients and generating segments for each request.Supporting tracing functions via decorators, middleware, and manual instrumentation.Supporting tracing AWS SDK v2 and v3 via AWS X-Ray SDK for Node.js.Auto-disable tracing when not running in the Lambda environment.  ","version":"Next","tagName":"h2"},{"title":"Install​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#install-1","content":" npmYarnpnpmBun npm install --save @aws-lambda-powertools/tracer   ","version":"Next","tagName":"h3"},{"title":"Options​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#options-1","content":" Class constructor accepts the following options, which are all optional:  serviceName (string): Service name to use that will be used in all log statements. Defaults to service_undefined.enabled (boolean): Whether to enable tracing. Defaults to true.captureHTTPsRequests (boolean): Whether to capture outgoing HTTP(S) requests as segment metadata. Defaults to true.  Middleware accepts the following options:  tracer (Tracer) (required): An instance of the Tracer class.option (object) (optional): An object with the following keys: captureResponse (boolean) (optional): Whether to capture the Lambda invocation result as segment metadata. Defaults to true.  ","version":"Next","tagName":"h3"},{"title":"Sample usage​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#sample-usage-1","content":" import middy from '@middy/core'; import { Tracer } from '@aws-lambda-powertools/tracer'; import { captureLambdaHandler } from '@aws-lambda-powertools/tracer/middleware'; import { SecretsManagerClient } from '@aws-sdk/client-secrets-manager'; const tracer = new Tracer({ serviceName: 'serverlessAirline' }); const client = tracer.captureAWSv3Client( new SecretsManagerClient({}) ); const lambdaHandler = async (event, context) =&gt; { tracer.putAnnotation('successfulBooking', true); }; export const handler = middy(lambdaHandler) .use(captureLambdaHandler(tracer));   The above code instructs the Tracer utility to create a custom segment named ## index.handler and to add an annotation to it with the key successfulBooking and the value true. The segment name is automatically generated based on the handler name, and the ## prefix is used to indicate that this is a custom segment. The Tracer utility also automatically captures the cold start and service name as annotations, and the Lambda invocation result or any error thrown as metadata. The segment data will be automatically sent to AWS X-Ray when the Lambda function completes its execution.  Tracer also automatically captures and traces any outgoing HTTP(S) requests made by the Lambda function. For example, if your function makes a request to a custom API, the Tracer utility will automatically create a segment for that request which will appear in your trace data and service map. Additionally, it will also capture any AWS SDK calls made by the function, and do the same for them.  ","version":"Next","tagName":"h3"},{"title":"Metrics​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#metrics","content":" Key features:  Aggregating up to 100 metrics using a single CloudWatch EMF object.Validating your metrics against common metric definitions mistakes (for example, metric unit, values, max dimensions, max metrics).Metrics are created asynchronously by the CloudWatch service. You do not need any custom stacks, and there is no impact to Lambda function latency.Creating a one-off metric with different dimensions.  If you're new to Amazon CloudWatch, there are a few terms like Namespace, Dimensions, Unit, etc, that you must be aware of before you start using the Metrics utility. To learn more about these terms, see the documentation on PowerTools Metrics.  ","version":"Next","tagName":"h2"},{"title":"Install​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#install-2","content":" npmYarnpnpmBun npm install --save @aws-lambda-powertools/metrics   ","version":"Next","tagName":"h3"},{"title":"Options​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#options-2","content":" Class constructor accepts the following options, which are all optional:  serviceName (string): Service name to use that will be used in all log statements. Defaults to service_undefined.defaultNamespace (string): Default namespace to use for all metrics. Defaults to default_namespace.  Middleware accepts the following options:  metrics (Metric) (required): An instance of the Metrics class.option (object) (optional): An object with the following keys: throwOnEmptyMetrics (boolean) (optional): Whether to throw an error if no metrics were added. Defaults to false.captureColdStartMetric (boolean) (optional): Whether to capture the cold start metric. Defaults to true.  ","version":"Next","tagName":"h3"},{"title":"Sample usage​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#sample-usage-2","content":" import middy from '@middy/core'; import { Metrics, MetricUnit } from '@aws-lambda-powertools/metrics'; import { logMetrics } from '@aws-lambda-powertools/metrics/middleware'; const metrics = new Metrics({ namespace: 'serverlessAirline', serviceName: 'orders' }); const lambdaHandler = async (event: unknown, context: unknown): Promise&lt;undefined&gt; =&gt; { metrics.addMetric('successfulBooking', MetricUnits.Count, 1); }; export const handler = middy(lambdaHandler) .use(logMetrics(metrics));   The above code will output a CloudWatch EMF object similar to the following:  { &quot;successfulBooking&quot;: 1.0, &quot;_aws&quot;: { &quot;Timestamp&quot;: 1592234975665, &quot;CloudWatchMetrics&quot;: [{ &quot;Namespace&quot;: &quot;successfulBooking&quot;, &quot;Dimensions&quot;: [ [ &quot;service&quot; ] ], &quot;Metrics&quot;: [{ &quot;Name&quot;: &quot;successfulBooking&quot;, &quot;Unit&quot;: &quot;Count&quot; }] }], &quot;service&quot;: &quot;orders&quot; } }   This EMF object will be sent to CloudWatch asynchronously by the CloudWatch service. You do not need any custom stacks, and there is no impact to Lambda function latency.  The Metrics utility supports high-resolution metrics as well as multi-value metrics. It also allows you to add default dimensions that are used in all the metrics emitted by your application or create a one-off metric with different dimensions.  ","version":"Next","tagName":"h3"},{"title":"Idempotency​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#idempotency","content":" Key features:  Prevent Lambda handler from executing more than once on the same event payload during a time windowEnsure Lambda handler returns the same result when called with the same payloadSelect a subset of the event as the idempotency key using JMESPath expressionsSet a time window in which records with the same payload should be considered duplicatesExpires in-progress executions if the Lambda function times out halfway through  The property of idempotency means that an operation does not cause additional side effects if it is called more than once with the same input parameters. Idempotent operations will return the same result when they are called multiple times with the same parameters. This makes idempotent operations safe to retry.  ","version":"Next","tagName":"h2"},{"title":"Install​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#install-3","content":" npmYarnpnpmBun npm install --save @aws-lambda-powertools/idempotency @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb   ","version":"Next","tagName":"h3"},{"title":"Options​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#options-3","content":" Middleware accepts the following options:  persistenceStore (BasePersistenceLayer): Class used to interact with a persistence store.config (IdempotencyConfig) (optional): Configuration object to customize the default behavior of the idempotency feature.  ","version":"Next","tagName":"h3"},{"title":"Sample usage​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#sample-usage-3","content":" import middy from '@middy/core'; import { randomUUID } from 'node:crypto'; import { makeHandlerIdempotent } from '@aws-lambda-powertools/idempotency/middleware'; import { DynamoDBPersistenceLayer } from '@aws-lambda-powertools/idempotency/dynamodb'; const persistenceStore = new DynamoDBPersistenceLayer({ tableName: 'idempotencyTableName', }); const createSubscriptionPayment = async ( event ) =&gt; { // ... create payment return { id: randomUUID(), productId: event.productId, }; }; export const handler = middy( async (event, context) =&gt; { try { const payment = await createSubscriptionPayment(event); return { paymentId: payment.id, message: 'success', statusCode: 200, }; } catch (error) { throw new Error('Error creating payment'); } } ).use( makeHandlerIdempotent({ persistenceStore, }) );   ","version":"Next","tagName":"h3"},{"title":"Best practices​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#best-practices","content":" ","version":"Next","tagName":"h2"},{"title":"Using multiple utilities​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#using-multiple-utilities","content":" You can use multiple Powertools utilities in your Lambda function by chaining the respective middlewares together. When doing so the Powertools team recommends that you place the Tracer middleware at the top of the middleware chain, followed by the Logger and any other middlewares.  This is because the Tracer middleware will create a new segment for each Lambda invocation, and the Logger might want to log the event that triggered the Lambda invocation. With this placement you will be able to have a segment that closely matches the actual duration of your Lambda function, and you will be able to see the event that triggered the function invocation before it's potentially modified by other middlewares.  export const handler = middy(() =&gt; { /* ... */ }) .use(captureLambdaHandler(tracer)) .use(injectLambdaContext(logger, { logEvent: true })) .use(logMetrics(metrics, { captureColdStartMetric: true }));   ","version":"Next","tagName":"h3"},{"title":"Cleaning up on early returns​","type":1,"pageTitle":"Powertools for AWS Lambda","url":"/docs/integrations/lambda-powertools#cleaning-up-on-early-returns","content":" As discussed in the early return section, some middlewares might need to stop the whole execution flow and return a response immediately. In this case, if you are writing your own middleware that will work with the Powertools utilities, you must make sure to clean up the utilities before returning.  For example, if you are using the Tracer utility, you must make sure to call the close method so that the Tracer can properly close the current segment and send it to X-Ray. Likewise, if you are using the Metrics utility, it's a good practice to call the clearMetrics method so that the Metrics utility can emit the metrics that were stored in the buffer and avoid you losing any data.  Following the example described in the linked section, you can clean up all the utilities by doing the following:  import { cleanupMiddlewares } from '@aws-lambda-powertools/commons'; // some function that calculates the cache id based on the current event const calculateCacheId = (event) =&gt; { /* ... */ } const storage = {} // middleware const cacheMiddleware = (options) =&gt; { let cacheKey const cacheMiddlewareBefore = async (request) =&gt; { cacheKey = options.calculateCacheId(request.event) if (Object.hasOwnProperty.call(options.storage, cacheKey)) { // clean up the Powertools utilities before returning cleanupMiddlewares() // exits early and returns the value from the cache if it's already there return options.storage[cacheKey] } } const cacheMiddlewareAfter = async (request) =&gt; { // stores the calculated response in the cache options.storage[cacheKey] = request.response } return { before: cacheMiddlewareBefore, after: cacheMiddlewareAfter } } // sample usage const handler = middy((event, context) =&gt; { /* ... */ }) .use(captureLambdaHandler(tracer)) .use(injectLambdaContext(logger, { logEvent: true })) .use(logMetrics(metrics, { captureColdStartMetric: true })) .use( cacheMiddleware({ calculateCacheId, storage }) );  ","version":"Next","tagName":"h3"},{"title":"How it works","type":0,"sectionRef":"#","url":"/docs/intro/how-it-works","content":"","keywords":"","version":"Next"},{"title":"Execution order​","type":1,"pageTitle":"How it works","url":"/docs/intro/how-it-works#execution-order","content":" Middlewares have two phases: before and after.  The before phase, happens before the handler is executed. In this code the response is not created yet, so you will have access only to the request.  The after phase, happens after the handler is executed. In this code you will have access to both the request and the response.  If you have three middlewares attached (as in the image above), this is the expected order of execution:  middleware1 (before)middleware2 (before)middleware3 (before)handlermiddleware3 (after)middleware2 (after)middleware1 (after)  Notice that in the after phase, middlewares are executed in inverted order, this way the first handler attached is the one with the highest priority as it will be the first able to change the request and last able to modify the response before it gets sent to the user. ","version":"Next","tagName":"h2"},{"title":"History","type":0,"sectionRef":"#","url":"/docs/intro/history","content":"","keywords":"","version":"Next"},{"title":"A brief history of Middy​","type":1,"pageTitle":"History","url":"/docs/intro/history#a-brief-history-of-middy","content":" Middy was started in the early days of AWS Lambda (~2016) and it was initially only used to remove duplication in a big serverless project with tons of lambdas. Only in August 2017 Middy's source code was released on GitHub making it an open source project.2017-08-03: First commit2017-09-04: v0.2.1 First release2020-04-25: v1.0.0 Released2020 Review by @lmammino2020 Review by @willfarrell2021: v2.0.0 Coming soon2021-04-01: v2.0.0 Released2021-02-02: 2021 Review from @lmammino2022-05-12: v3.0.0 Released2022-11-24: v4.0.0 Released2023-08-22: JSAwardsIE 2023 Most valued JavaScript open source project2023-11-15: v5.0.0 Released2024-11-??: v6.0.0 Released  Fun Fact: The adding of the emoji-icon was the 2nd commit to the project. ","version":"Next","tagName":"h2"},{"title":"Hooks","type":0,"sectionRef":"#","url":"/docs/intro/hooks","content":"Hooks Middy provides hooks into it's core to allow for monitoring, setup, and cleaning that may not be possible within a middleware. In order of execution beforePrefetch(): Triggered once before middlewares are attached and prefetches are executed.requestStart(): Triggered on every request before the first middleware.beforeMiddleware/afterMiddleware(fctName): Triggered before/after every before, after, and onError middleware function. The function name is passed in, this is why all middlewares use a verbose naming pattern.beforeHandler/afterHandler(): Triggered before/after the handler.requestEnd(request): Triggered right before the response is returned, including thrown errors. See Profiling for example usage.","keywords":"","version":"Next"},{"title":"Influence","type":0,"sectionRef":"#","url":"/docs/intro/influence","content":"Influence Middy has been one of the first projects to encourage the adoption of middlewares to simplify code reuse and best practices within the context of Lambda. Since middy started to gain popularity in the Node.js ecosystem, we have seen some independent projects taking the same ideas to other ecosystems: .Net port Voxel.MiddyNet @vgaltesGoLang port Vesper Do you have a similar project? Let us know.","keywords":"","version":"Next"},{"title":"Release Cycle","type":0,"sectionRef":"#","url":"/docs/intro/release-cycle","content":"Release Cycle Each major release has a two (2) month Alpha period, one (1) month Beta, before a full release and becomes Stable. Each release goes into Maintenance after nine (9) months, as the next release enters Alpha. This time period is chosen for alignment with AWS Lambda nodejs runtime releases. All Node.js Long-Term Support (LTS) releases that have AWS Lambda runtimes are supported. Version\tStatus\tAlpha Release\tStable Release\tEnd-of-Lifev7\tScoping\t2025-??-??\t2025-10-28\t2027-04-30 v6\tStable\t2024-10-16\t2024-11-23\t2026-04-30 v5\tDeprecated\t2023-06-01\t2023-11-15\t2025-04-30 v4\tDeprecated\t2022-10-17\t2022-11-24\t2023-11-15 v3\tDeprecated\t2022-01-04\t2022-05-12\t2022-12-31 v2\tDeprecated\t2021-01-24\t2021-04-01\t2022-05-12 v1\tDeprecated\t2018-05-20\t2020-04-25\t2021-04-01 v0\tDeprecated\t2017-08-03\t2017-09-04\t2020-04-25 Dates are subject to change. If your organization requires a longer maintenance period of Middy, please reach out.","keywords":"","version":"Next"},{"title":"Sponsoring","type":0,"sectionRef":"#","url":"/docs/intro/sponsoring","content":"Sponsoring If Middy is adding value to your project or organization and you would like to support its long term maintenance, becoming a sponsor is a great way to do that. GitHub Sponsors","keywords":"","version":"Next"},{"title":"Streamify Response","type":0,"sectionRef":"#","url":"/docs/intro/streamify-response","content":"","keywords":"","version":"Next"},{"title":"Lambda Function URL Example​","type":1,"pageTitle":"Streamify Response","url":"/docs/intro/streamify-response#lambda-function-url-example","content":" import middy from '@middy/core' import { createReadableStream } from '@datastream/core' const lambdaHandler = (event, context) =&gt; { return { statusCode: 200, headers: { 'Content-Type': 'text/csv' }, body: createReadableStream('...') // or string } } export const handler = middy({ streamifyResponse: true }).handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Lambda InvokeWithResponseStream Example​","type":1,"pageTitle":"Streamify Response","url":"/docs/intro/streamify-response#lambda-invokewithresponsestream-example","content":" import middy from '@middy/core' import { createReadableStream } from '@datastream/core' const lambdaHandler = (event, context) =&gt; { return createReadableStream('...') // or string } export const handler = middy({ streamifyResponse: true }).handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Requesting Lambda​","type":1,"pageTitle":"Streamify Response","url":"/docs/intro/streamify-response#requesting-lambda","content":" import { LambdaClient, InvokeWithResponseStreamCommand } from '@aws-sdk/client-lambda' const lambda = new LambdaClient() const res = await lambda.send( new InvokeWithResponseStreamCommand({ FunctionName: 'function-name', Payload: JSON.stringify({...}) }) ) const decoder = new TextDecoder('utf-8') let body = '' for await (const chunk of res.EventStream) { if (chunk?.PayloadChunk?.Payload) { body += decoder.decode(Buffer.from(chunk.PayloadChunk.Payload)) } }  ","version":"Next","tagName":"h3"},{"title":"Testing","type":0,"sectionRef":"#","url":"/docs/intro/testing","content":"","keywords":"","version":"Next"},{"title":"jest and typescript​","type":1,"pageTitle":"Testing","url":"/docs/intro/testing#jest-and-typescript","content":" If you use middy v5+, jest and typescript, and use ts-jest as a transformer, then you need to ensure that middy modules are not transformed. Use this in your jest.config.ts file  const esModules = [&quot;@middy&quot;].join(&quot;|&quot;) const jestConfig: JestConfigWithTsJest = { ... transform: { &quot;^.+\\\\.ts?$&quot;: [ &quot;ts-jest&quot;, { useESM: true } ] }, transformIgnorePatterns: [`node_modules/(?!${esModules})`], ... } export default jestConfig   You must also use the flag --experimental-vm-modules when running jest - eg have this in your package.json file  { ... &quot;scripts&quot;: { ... &quot;test&quot;: &quot;NODE_OPTIONS=--experimental-vm-modules jest&quot;, ... }, ... }   See https://kulshekhar.github.io/ts-jest/docs/guides/esm-support/ and https://jestjs.io/docs/ecmascript-modules for more details ","version":"Next","tagName":"h2"},{"title":"Utilities","type":0,"sectionRef":"#","url":"/docs/intro/utilities","content":"Utilities caution This page is a work in progress. If you want to help us to make this page better, please consider contributing on GitHub.","keywords":"","version":"Next"},{"title":"cloudformation-response","type":0,"sectionRef":"#","url":"/docs/middlewares/cloudformation-response","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"cloudformation-response","url":"/docs/middlewares/cloudformation-response#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/cloudformation-response   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"cloudformation-response","url":"/docs/middlewares/cloudformation-response#options","content":" None  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"cloudformation-response","url":"/docs/middlewares/cloudformation-response#sample-usage","content":" ","version":"Next","tagName":"h2"},{"title":"General​","type":1,"pageTitle":"cloudformation-response","url":"/docs/middlewares/cloudformation-response#general","content":" import middy from '@middy/core' import cloudformationResponse from '@middy/cloudformation-response' export const handler = middy((event, context) =&gt; { return { PhysicalResourceId:'...' } }) handler.use(cloudformationResponse())  ","version":"Next","tagName":"h3"},{"title":"do-not-wait-for-empty-event-loop","type":0,"sectionRef":"#","url":"/docs/middlewares/do-not-wait-for-empty-event-loop","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"do-not-wait-for-empty-event-loop","url":"/docs/middlewares/do-not-wait-for-empty-event-loop#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/do-not-wait-for-empty-event-loop   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"do-not-wait-for-empty-event-loop","url":"/docs/middlewares/do-not-wait-for-empty-event-loop#options","content":" By default the middleware sets the callbackWaitsForEmptyEventLoop property to false only in the before phase, meaning you can override it in handler to true if needed. You can set it in all steps with the options:  runOnBefore (defaults to true) - sets property before running your handlerrunOnAfter (defaults to false)runOnError (defaults to false)  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"do-not-wait-for-empty-event-loop","url":"/docs/middlewares/do-not-wait-for-empty-event-loop#sample-usage","content":" import middy from '@middy/core' import doNotWaitForEmptyEventLoop from '@middy/do-not-wait-for-empty-event-loop' const lambdaHandler = (event, context) =&gt; { return {} } export const handler = middy() .use(doNotWaitForEmptyEventLoop({ runOnError: true })) .handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"Use with TypeScript","type":0,"sectionRef":"#","url":"/docs/intro/typescript","content":"Use with TypeScript Middy can be used with TypeScript with typings built in in every official package. You may need to install additional types for AWS Lambda events. npm i -D @types/aws-lambda Here's an example of how you might be using Middy with TypeScript for a Lambda receiving events from API Gateway and fetching secrets from Secrets Manager: import middy from '@middy/core' import secretsManager from '@middy/secrets-manager' import type { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda' export const handler = middy&lt;APIGatewayProxyEvent, APIGatewayProxyResult&gt;() .use( secretsManager({ fetchData: { apiToken: 'dev/api_token' }, awsClientOptions: { region: 'us-east-1' }, setToContext: true }) ) .handler(async (req, context) =&gt; { // The context type gets augmented here by the secretsManager middleware. // This is just an example, obviously don't ever log your secret in real life! console.log(context.apiToken) return { statusCode: 200, body: JSON.stringify({ message: `Hello from ${req.path}`, req }) } }) Note that when using TypeScript, you should use what we call the Middleware-first, Handler-last approach, which means that you should always call the handler method last, after you have attached all the middlewares you need. This approach makes sure that, as you attach middlewares, the type system understands how the event and the context arguments are augmented by the various middlewares and inside your handler code you can have a nice type-checking and auto-completion experience. You can also write custom middlewares with TypeScript. This is an example tsconfig.json file that can be used for typescript projects { &quot;compilerOptions&quot;: { &quot;incremental&quot;: true, &quot;target&quot;: &quot;es2020&quot;, &quot;module&quot;: &quot;es2020&quot;, &quot;declaration&quot;: true, &quot;sourceMap&quot;: true, &quot;composite&quot;: true, &quot;strict&quot;: true, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;esModuleInterop&quot;: true, &quot;skipLibCheck&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;preserveConstEnums&quot;: true, &quot;resolveJsonModule&quot;: true, &quot;allowJs&quot;: true, &quot;rootDir&quot;: &quot;.&quot;, &quot;outDir&quot;: &quot;lib&quot; }, &quot;include&quot;: [&quot;src/**/*&quot;, &quot;tests/**/*&quot;], &quot;exclude&quot;: [&quot;node_modules&quot;] } ","keywords":"","version":"Next"},{"title":"cloudwatch-metrics","type":0,"sectionRef":"#","url":"/docs/middlewares/cloudwatch-metrics","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"cloudwatch-metrics","url":"/docs/middlewares/cloudwatch-metrics#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/cloudwatch-metrics   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"cloudwatch-metrics","url":"/docs/middlewares/cloudwatch-metrics#options","content":" namespace (string) (optional): Defaults to aws-embedded-metrics. Sets the CloudWatch namespace that extracted metrics should be published to.dimensions (Record&lt;String, String&gt; | Record&lt;String, String&gt;[]) (optional): Explicitly overrides all dimensions. This will remove the default dimensions. You can provide an empty array to record all metrics without dimensions. For dimensions defaults and configuration see the aws-embedded-metrics docs.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"cloudwatch-metrics","url":"/docs/middlewares/cloudwatch-metrics#sample-usage","content":" const middy = require('@middy/core') const cloudwatchMetrics = require('@middy/cloudwatch-metrics') const lambdaHandler = (event, context) =&gt; { context.metrics.putMetric('ProcessingLatency', 100, 'Milliseconds') context.metrics.setProperty( 'RequestId', '422b1569-16f6-4a03-b8f0-fe3fd9b100f8' ) } export const handler = middy() .use( cloudwatchMetrics({ namespace: 'myAppliction', dimensions: [{ Action: 'Buy' }] }) ) .handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"appconfig","type":0,"sectionRef":"#","url":"/docs/middlewares/appconfig","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"appconfig","url":"/docs/middlewares/appconfig#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/appconfig npm install --save-dev @aws-sdk/client-appconfigdata   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"appconfig","url":"/docs/middlewares/appconfig#options","content":" AwsClient (object) (default AppConfigClient): AppConfigClient class constructor (i.e. that has been instrumented with AWS XRay). Must be from @aws-sdk/client-appconfig.awsClientOptions (object) (default undefined): Options to pass to AppConfigClient class constructor.awsClientAssumeRole (string) (default undefined): Internal key where secrets are stored. See @middy/sts on to set this.awsClientCapture (function) (default undefined): Enable XRay by passing captureAWSv3Client from aws-xray-sdk in.fetchData (object) (required): Mapping of internal key name to API request parameters.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default appconfig): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store credentials to request.context.  NOTES:  Lambda is required to have IAM permission for appconfig:StartConfigurationSession and appconfig:GetLatestConfiguration  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"appconfig","url":"/docs/middlewares/appconfig#sample-usage","content":" import middy from '@middy/core' import appConfig from '@middy/appconfig' const handler = middy() .use( appConfig({ fetchData: { config: { Application: '...', ClientId: '...', Configuration: '...', Environment: '...' } } }) ) .handler((event, context) =&gt; { const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) } return response })   ","version":"Next","tagName":"h2"},{"title":"Bundling​","type":1,"pageTitle":"appconfig","url":"/docs/middlewares/appconfig#bundling","content":" To exclude @aws-sdk add @aws-sdk/client-appconfig to the exclude list.  ","version":"Next","tagName":"h2"},{"title":"Usage with TypeScript​","type":1,"pageTitle":"appconfig","url":"/docs/middlewares/appconfig#usage-with-typescript","content":" Data in AppConfig can be stored as arbitrary structured data. It's not possible to know in advance what shape the fetched data will have, so by default the fetched parameters will have type unknown.  You can provide some type hints by leveraging the appConfigReq utility function. This function allows you to specify what's the expected type that will be fetched for every AppConfig request.  The idea is that, for every request specified in the fetchData option, rather than just providing the parameter path as a string, you can wrap it in a appConfigReq&lt;ParamType&gt;(config) call. Internally, appConfigReq is a function that will return config as received, but it allows you to use generics to provide type hints for the expected type for that parameter.  This way TypeScript can understand how to treat the additional data attached to the context and stored in the internal storage.  The following example illustrates how to use appConfigReq:  import middy from '@middy/core' import appConfig, { appConfigReq } from '@middy/appconfig' const lambdaHandler = (event, context) =&gt; { return { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) } }) export const handler = middy() .use( appConfig({ fetchData: { config: { Application: '...', ClientId: '...', Configuration: '...', Environment: '...' } } }) ) .before(async (request) =&gt; { const data = await getInternal('config', request) // data.config.field1 (string) // data.config.field2 (string) // data.config.field3 (number) }) .handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"error-logger","type":0,"sectionRef":"#","url":"/docs/middlewares/error-logger","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"error-logger","url":"/docs/middlewares/error-logger#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/error-logger   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"error-logger","url":"/docs/middlewares/error-logger#options","content":" logger property: a function (default (request) =&gt; console.error(request.error)) that is used to define the logging logic. It receives the Error object as first and only parameter.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"error-logger","url":"/docs/middlewares/error-logger#sample-usage","content":" import middy from '@middy/core' import errorLogger from '@middy/error-logger' const lambdaHandler = (event, context) =&gt; { // your handler logic } export const handler = middy().use(errorLogger()).handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"event-normalizer","type":0,"sectionRef":"#","url":"/docs/middlewares/event-normalizer","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"event-normalizer","url":"/docs/middlewares/event-normalizer#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/event-normalizer   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"event-normalizer","url":"/docs/middlewares/event-normalizer#options","content":" wrapNumbers (boolean) (default undefined): Whether to return numbers as a string instead of converting them to native JavaScript numbers. This allows for the safe round-trip transport of numbers of arbitrary size. For DynamoDB Events only.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"event-normalizer","url":"/docs/middlewares/event-normalizer#sample-usage","content":" import middy from '@middy/core' import eventNormalizer from '@middy/event-normalizer' const lambdaHandler = (event, context) =&gt; { const { Records } = event for (const record of Records) { // ... } } export const handler = middy().use(eventNormalizer()).handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"dynamodb","type":0,"sectionRef":"#","url":"/docs/middlewares/dynamodb","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"dynamodb","url":"/docs/middlewares/dynamodb#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/dynamodb npm install --save-dev @aws-sdk/client-dynamodb @aws-sdk/util-dynamodb   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"dynamodb","url":"/docs/middlewares/dynamodb#options","content":" AwsClient (object) (default DynamoDBClient): DynamoDBClient class constructor (i.e. that has been instrumented with AWS XRay). Must be from @aws-sdk/client-dynamodb.awsClientOptions (object) (default undefined): Options to pass to DynamoDBClient class constructor.awsClientAssumeRole (string) (default undefined): Internal key where secrets are stored. See @middy/sts on to set this.awsClientCapture (function) (default undefined): Enable XRay by passing captureAWSv3Client from aws-xray-sdk in.fetchData (object) (required): Mapping of internal key name to API request parameters.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default dynamodb): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store credentials to request.context.  NOTES:  Lambda is required to have IAM permission for dynamodb:BatchGetItemCommand  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"dynamodb","url":"/docs/middlewares/dynamodb#sample-usage","content":" import middy from '@middy/core' import dynamodb from '@middy/dynamodb' const lambdaHandler = (event, context) =&gt; { const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) } return response } export const handler = middy() .use( dynamodb({ fetchData: { config: { TableName: '...', Key: { pk: '0000' } } } }) ) .handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Bundling​","type":1,"pageTitle":"dynamodb","url":"/docs/middlewares/dynamodb#bundling","content":" To exclude @aws-sdk add @aws-sdk/client-dynamodb to the exclude list.  ","version":"Next","tagName":"h2"},{"title":"Usage with TypeScript​","type":1,"pageTitle":"dynamodb","url":"/docs/middlewares/dynamodb#usage-with-typescript","content":" Data in DynamoDB can be stored as arbitrary structured data. It's not possible to know in advance what shape the fetched data will have, so by default the fetched parameters will have type Record&lt;string, NativeAttributeValue&gt;.  You can provide some type hints by leveraging the dynamoDbReq utility function. This function allows you to specify what's the expected type that will be fetched for every DynamoDB request.  The idea is that, for every request specified in the fetchData option, rather than just providing the parameter configuration as an object, you can wrap it in a dynamoDbReq&lt;ParamType&gt;(config) call. Internally, dynamoDbReq is a function that will return config as received, but it allows you to use generics to provide type hints for the expected fetched value type for that request.  This way TypeScript can understand how to treat the additional data attached to the context and stored in the internal storage.  The following example illustrates how to use dynamoDbReq:  import middy from '@middy/core' import dynamodb, { dynamoDbReq } from '@middy/dynamodb' const handler = middy((event, context) =&gt; { const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) } return response }) handler.use( dynamodb({ fetchData: { config: dynamoDbReq&lt;{field1: string, field2: string, field3: number}&gt;({ TableName: '...' Key: { pk: '0000' } }) } }) ) .before(async (request) =&gt; { const data = await getInternal('config', request) // data.config.field1 (string) // data.config.field2 (string) // data.config.field3 (number) })  ","version":"Next","tagName":"h2"},{"title":"http-content-encoding","type":0,"sectionRef":"#","url":"/docs/middlewares/http-content-encoding","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-content-encoding","url":"/docs/middlewares/http-content-encoding#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-content-encoding   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-content-encoding","url":"/docs/middlewares/http-content-encoding#options","content":" br (object) (default {}): zlib.createBrotliCompress brotliOptionsgzip (object) (default {}): zlib.createGzip gzipOptionsdeflate (object) (default {}): zlib.createDeflate deflateOptionsoverridePreferredEncoding (array[string]) (optional): Override the preferred encoding order, most browsers prefer gzip over br, even though br has higher compression. Default: []  NOTES:  Important For br encoding NodeJS defaults to 11. Levels 10 &amp; 11 have been shown to have lower performance for the level of compression they apply. Testing is recommended to ensure the right balance of compression &amp; performance.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-content-encoding","url":"/docs/middlewares/http-content-encoding#sample-usage","content":" import middy from '@middy/core' import httpContentNegotiation from '@middy/http-content-negotiation' import httpContentEncoding from '@middy/http-content-encoding' import { constants } from 'node:zlib' export const handler = middy() .use(httpContentNegotiation()) .use(httpContentEncoding({ br: { params: { [constants.BROTLI_PARAM_MODE]: constants.BROTLI_MODE_TEXT, // adjusted for UTF-8 text [constants.BROTLI_PARAM_QUALITY]: 7 } }, overridePreferredEncoding: ['br', 'gzip', 'deflate'] }) .handler((event, context) =&gt; { return { statusCode: 200, body: '{...}' } })   ","version":"Next","tagName":"h2"},{"title":"Using streams​","type":1,"pageTitle":"http-content-encoding","url":"/docs/middlewares/http-content-encoding#using-streams","content":" import middy from '@middy/core' import httpContentNegotiation from '@middy/http-content-negotiation' import httpContentEncoding from '@middy/http-content-encoding' import { constants } from 'node:zlib' import { createReadableStream } from '@datastream/core' const lambdaHandler = (event, context) =&gt; { return { statusCode: 200, body: createReadableStream('{...}') } } export const handler = middy({ streamifyResponse: true }) .use(httpContentNegotiation()) .use(httpContentEncoding({ br: { params: { [constants.BROTLI_PARAM_MODE]: constants.BROTLI_MODE_TEXT, // adjusted for UTF-8 text [constants.BROTLI_PARAM_QUALITY]: 7 } }, overridePreferredEncoding: ['br', 'gzip', 'deflate'] }) .handler(lambdaHandler)  ","version":"Next","tagName":"h3"},{"title":"http-cors","type":0,"sectionRef":"#","url":"/docs/middlewares/http-cors","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-cors","url":"/docs/middlewares/http-cors#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-cors   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-cors","url":"/docs/middlewares/http-cors#options","content":" credentials (bool) (optional): if true, sets Access-Control-Allow-Credentials (default false)disableBeforePreflightResponse (bool) (optional): if false, replies automatically to cors preflight requests. Set to true if handling the response in a custom way (default true)headers (string) (optional): value to put in Access-Control-Allow-Headers (default: false)methods (string) (optional): value to put in Access-Control-Allow-Methods (default: false)getOrigin (function(incomingOrigin:string, options)) (optional): take full control of the generating the returned origin. Defaults to using the origin or origins option.origin (string) (optional): default origin to put in the header (default: null, will exclude this header).origins (array) (optional): An array of allowed origins. The incoming origin is matched against the list and is returned if present. If the incoming origin is not found, the header will not be returned. Wildcards can be used within the origin to match multiple origins.exposeHeaders (string) (optional): value to put in Access-Control-Expose-Headers (default: false)maxAge (string) (optional): value to put in Access-Control-Max-Age header (default: null)requestHeaders (string) (optional): value to put in Access-Control-Request-Headers (default: false)requestMethods (string) (optional): value to put in Access-Control-Request-Methods (default: false)cacheControl (string) (optional): value to put in Cache-Control header on pre-flight (OPTIONS) requests (default: null)  import middy from '@middy/core' import httpErrorHandler from '@middy/http-error-handler' import cors from '@middy/http-cors' const lambdaHandler = (event, context) =&gt; { throw new createError.UnprocessableEntity() } export const handler = middy() .use(httpErrorHandler()) .use(cors()) .handler(lambdaHandler) // when Lambda runs the handler... handler({}, {}, (_, response) =&gt; { equal(response.headers['Access-Control-Allow-Origin'], '*') deepEqual(response, { statusCode: 422, body: 'Unprocessable Entity' }) })   ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-cors","url":"/docs/middlewares/http-cors#sample-usage","content":" import middy from '@middy/core' import cors from '@middy/http-cors' const lambdaHandler = (event, context) =&gt; { return {} } export const handler = middy().use(cors()).handler(lambdaHandler) // when Lambda runs the handler... handler({}, {}, (_, response) =&gt; { equal(response.headers['Access-Control-Allow-Origin'], '*') })  ","version":"Next","tagName":"h2"},{"title":"http-content-negotiation","type":0,"sectionRef":"#","url":"/docs/middlewares/http-content-negotiation","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-content-negotiation","url":"/docs/middlewares/http-content-negotiation#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-content-negotiation   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-content-negotiation","url":"/docs/middlewares/http-content-negotiation#options","content":" parseCharsets (defaults to true) - Allows enabling/disabling the charsets parsingavailableCharsets (defaults to undefined) - Allows defining the list of charsets supported by the Lambda functionparseEncodings (defaults to true) - Allows enabling/disabling the encodings parsingavailableEncodings (defaults to undefined) - Allows defining the list of encodings supported by the Lambda functionparseLanguages (defaults to true) - Allows enabling/disabling the languages parsingavailableLanguages (defaults to undefined) - Allows defining the list of languages supported by the Lambda function. Setting to en will match with locales like en-*. Setting to en-US will match with language en.parseMediaTypes (defaults to true) - Allows enabling/disabling the media types parsingavailableMediaTypes (defaults to undefined) - Allows defining the list of media types supported by the Lambda functionfailOnMismatch (defaults to true) - If set to true it will throw an HTTP NotAcceptable (406) exception when the negotiation fails for one of the headers (e.g. none of the languages requested are supported by the app)  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-content-negotiation","url":"/docs/middlewares/http-content-negotiation#sample-usage","content":" import middy from '@middy/core' import httpContentNegotiation from '@middy/http-content-negotiation' import httpHeaderNormalizer from '@middy/http-header-normalizer' import httpErrorHandler from '@middy/http-error-handler' const lambdaHandler = (event, context) =&gt; { let message, body switch (context.preferredLanguage) { case 'it-it': message = 'Ciao Mondo' break case 'fr-fr': message = 'Bonjour le monde' break default: message = 'Hello world' } switch (context.preferredMediaType) { case 'application/xml': body = `&lt;message&gt;${message}&lt;/message&gt;` break case 'application/yaml': body = `---\\nmessage: ${message}` break case 'application/json': body = JSON.stringify({ message }) break default: body = message } return { statusCode: 200, body } } export const handler = middy() .use(httpHeaderNormalizer()) .use( httpContentNegotiation({ parseCharsets: false, parseEncodings: false, availableLanguages: ['it-it', 'fr-fr', 'en'], availableMediaTypes: [ 'application/xml', 'application/yaml', 'application/json', 'text/plain' ] }) ) .use(httpErrorHandler()) .handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"http-header-normalizer","type":0,"sectionRef":"#","url":"/docs/middlewares/http-header-normalizer","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-header-normalizer","url":"/docs/middlewares/http-header-normalizer#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-header-normalizer   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-header-normalizer","url":"/docs/middlewares/http-header-normalizer#options","content":" canonical (bool) (optional): if true, modifies the headers to canonical format, otherwise the headers are normalized to lowercase (default false)defaultHeaders (object) (optional): Default headers to used if any are missing. i.e. Content-Type (default {})normalizeHeaderKey (function) (optional): a function that accepts an header name as a parameter and returns its canonical representation.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-header-normalizer","url":"/docs/middlewares/http-header-normalizer#sample-usage","content":" import middy from '@middy/core' import httpHeaderNormalizer from '@middy/http-header-normalizer' const lambdaHandler = (event, context) =&gt; { return {} } export const handler = middy() .use(httpHeaderNormalizer()) .handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"http-error-handler","type":0,"sectionRef":"#","url":"/docs/middlewares/http-error-handler","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-error-handler","url":"/docs/middlewares/http-error-handler#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-error-handler   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-error-handler","url":"/docs/middlewares/http-error-handler#options","content":" logger (defaults to console.error) - a logging function that is invoked with the current error as an argument. You can pass false if you don't want the logging to happen.fallbackMessage (default undefined) - When non-http errors (those without statusCode) occur you can set a fallback message to be used. These will be returned with a 500 status code.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-error-handler","url":"/docs/middlewares/http-error-handler#sample-usage","content":" import middy from '@middy/core' import httpErrorHandler from '@middy/http-error-handler' import createError from 'http-errors' const lambdaHandler = (event, context) =&gt; { throw new createError.UnprocessableEntity() } export const handler = middy().use(httpErrorHandler()).handler(lambdaHandler) // when Lambda runs the handler... handler({}, {}, (_, response) =&gt; { deepEqual(response, { statusCode: 422, body: 'Unprocessable Entity' }) })  ","version":"Next","tagName":"h2"},{"title":"http-event-normalizer","type":0,"sectionRef":"#","url":"/docs/middlewares/http-event-normalizer","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-event-normalizer","url":"/docs/middlewares/http-event-normalizer#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-event-normalizer   ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-event-normalizer","url":"/docs/middlewares/http-event-normalizer#sample-usage","content":" import middy from '@middy/core' import httpEventNormalizer from '@middy/http-event-normalizer' const lambdaHander = (event, context) =&gt; { console.log(`Hello user ${event.pathParameters.userId}`) // might produce `Hello user undefined`, but not an error return {} } export const handler = middy().use(httpEventNormalizer()).handler(lambdaHander)  ","version":"Next","tagName":"h2"},{"title":"http-json-body-parser","type":0,"sectionRef":"#","url":"/docs/middlewares/http-json-body-parser","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-json-body-parser","url":"/docs/middlewares/http-json-body-parser#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-json-body-parser   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-json-body-parser","url":"/docs/middlewares/http-json-body-parser#options","content":" reviver (function) (optional): A reviver parameter may be passed which will be used JSON.parseing the body.disableContentTypeError (boolean) (optional): Skip throwing 415 when Content-Type is invalid. Default: false.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-json-body-parser","url":"/docs/middlewares/http-json-body-parser#sample-usage","content":" import middy from '@middy/core' import httpHeaderNormalizer from '@middy/http-header-normalizer' import httpJsonBodyParser from '@middy/http-json-body-parser' const lambdaHandler = (event, context) =&gt; { return {} } export const handler = middy() .use(httpHeaderNormalizer()) .use(httpJsonBodyParser()) .handler(lambdaHandler) // invokes the handler const event = { headers: { 'Content-Type': 'application/json' // It is important that the request has the proper content type. }, body: JSON.stringify({ foo: 'bar' }) } handler(event, {}, (_, body) =&gt; { equal(body, { foo: 'bar' }) })  ","version":"Next","tagName":"h2"},{"title":"http-multipart-body-parser","type":0,"sectionRef":"#","url":"/docs/middlewares/http-multipart-body-parser","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-multipart-body-parser","url":"/docs/middlewares/http-multipart-body-parser#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-multipart-body-parser   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-multipart-body-parser","url":"/docs/middlewares/http-multipart-body-parser#options","content":" busboy (object) (optional): defaults to {} and it can be used to pass extraparameters to the internal busboy instance at creation time. Checkout the official documentation for more information on the supported options.charset (string) (default utf8): it can be used to change default charset. Set to binary when recieving images.disableContentTypeError (boolean) (optional): Skip throwing 415 when Content-Type is invalid. Default: false.  Note: this middleware will buffer all the data as it is processed internally by busboy, so, if you are using this approach to parse significantly big volumes of data, keep in mind that all the data will be allocated in memory. This is somewhat inevitable with Lambdas (as the data is already encoded into the JSON in memory as Base64), but it's good to keep this in mind and evaluate the impact on you application. If you really have to deal with big files, then you might also want to consider to allowing your users to directly upload files to S3  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-multipart-body-parser","url":"/docs/middlewares/http-multipart-body-parser#sample-usage","content":" import middy from '@middy/core' import httpHeaderNormalizer from '@middy/http-header-normalizer' import httpMultipartBodyParser from '@middy/http-multipart-body-parser' const lambdaHandler = (event, context) =&gt; { return {} } export const handler = middy() .use(httpHeaderNormalizer()) .use(httpMultipartBodyParser()) .handler(lambdaHandler) // invokes the handler const event = { headers: { 'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryppsQEwf2BVJeCe0M' }, body: 'LS0tLS0tV2ViS2l0Rm9ybUJvdW5kYXJ5cHBzUUV3ZjJCVkplQ2UwTQ0KQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPSJmb28iDQoNCmJhcg0KLS0tLS0tV2ViS2l0Rm9ybUJvdW5kYXJ5cHBzUUV3ZjJCVkplQ2UwTS0t', isBase64Encoded: true } handler(event, {}, (_, body) =&gt; { equal(body, { foo: 'bar' }) })  ","version":"Next","tagName":"h2"},{"title":"http-partial-response","type":0,"sectionRef":"#","url":"/docs/middlewares/http-partial-response","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-partial-response","url":"/docs/middlewares/http-partial-response#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-partial-response   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-partial-response","url":"/docs/middlewares/http-partial-response#options","content":" filteringKeyName (string) (optional): defaults to fields the querystring key that will be used to filter the response.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-partial-response","url":"/docs/middlewares/http-partial-response#sample-usage","content":" import middy from '@middy/core' import httpPartialResponse from '@middy/http-partial-response' const lambdaHandler = (event, context) =&gt; { const response = { statusCode: 200, body: { firstname: 'John', lastname: 'Doe', gender: 'male', age: 30, address: { street: 'Avenue des Champs-Élysées', city: 'Paris' } } } return response } export const handler = middy().use(httpPartialResponse()).handler(lambdaHandler) const event = { queryStringParameters: { fields: 'firstname,lastname' } } handler(event, {}, (_, response) =&gt; { expect(response.body).toEqual({ firstname: 'John', lastname: 'Doe' }) })  ","version":"Next","tagName":"h2"},{"title":"http-security-headers","type":0,"sectionRef":"#","url":"/docs/middlewares/http-security-headers","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-security-headers","url":"/docs/middlewares/http-security-headers#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-security-headers   ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"http-security-headers","url":"/docs/middlewares/http-security-headers#features","content":" dnsPrefetchControl controls browser DNS prefetchingframeguard to prevent clickjackinghidePoweredBy to remove the Server/X-Powered-By headerhsts for HTTP Strict Transport SecurityieNoOpen sets X-Download-Options for IE8+noSniff to keep clients from sniffing the MIME typereferrerPolicy to hide the Referer headerxssFilter adds some small XSS protections  ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-security-headers","url":"/docs/middlewares/http-security-headers#options","content":" There are a lot, see source  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-security-headers","url":"/docs/middlewares/http-security-headers#sample-usage","content":" import middy from '@middy/core' import httpSecurityHeaders from '@middy/http-security-headers' const lambdaHandler = (event, context) =&gt; { return {} } export const handler = middy().use(httpSecurityHeaders()).handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"http-response-serializer","type":0,"sectionRef":"#","url":"/docs/middlewares/http-response-serializer","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-response-serializer","url":"/docs/middlewares/http-response-serializer#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-response-serializer   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-response-serializer","url":"/docs/middlewares/http-response-serializer#options","content":" defaultContentType (optional): used if the request and handler don't specify what type is wanted.serializers (array): Array for regex and serializer function.  { serializers: [ { regex: /^application\\/xml$/, serializer: ({ body }) =&gt; `&lt;message&gt;${body}&lt;/message&gt;`, }, { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) }, { regex: /^text\\/plain$/, serializer: ({ body }) =&gt; body } ], defaultContentType: 'application/json' }   ","version":"Next","tagName":"h2"},{"title":"Serializer Functions​","type":1,"pageTitle":"http-response-serializer","url":"/docs/middlewares/http-response-serializer#serializer-functions","content":" When a matching serializer is found, the Content-Type header is set and the serializer function is run.  The function is passed the entire response object, and should return either a string or an object.  If a string is returned, the body attribute of the response is updated.  If an object with a body attribute is returned, the entire response object is replaced. This is useful if you want to manipulate headers or add additional attributes in the Lambda response.  ","version":"Next","tagName":"h2"},{"title":"Content Type Negotiation​","type":1,"pageTitle":"http-response-serializer","url":"/docs/middlewares/http-response-serializer#content-type-negotiation","content":" The header is not the only way the middleware decides which serializer to execute.  The content type is determined in the following order:  event.requiredContentType -- allows the handler to override everything else (legacy, will be deprecated in v6)context.preferredMediaTypes -- allows the handler to override the default, but lets the request ask firstdefaultContentType middleware configuration  All options allow for multiple types to be specified in your order of preference, and the first matching serializer will be executed. When planning to use Accept, an external input, it is recommended to validate that it is an expected value.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-response-serializer","url":"/docs/middlewares/http-response-serializer#sample-usage","content":" import middy from '@middy/core' import httpContentNegotiation from '@middy/http-content-negotiation' import httpResponseSerializer from '@middy/http-response-serializer' const lambdaHandler = (event, context) =&gt; { const body = 'Hello World' return { statusCode: 200, body } } export const handler = middy() .use(httpContentNegotiation()) // Creates `context.preferredMediaTypes` .use( httpResponseSerializer({ serializers: [ { regex: /^application\\/xml$/, serializer: ({ body }) =&gt; `&lt;message&gt;${body}&lt;/message&gt;` }, { regex: /^application\\/json$/, serializer: ({ body }) =&gt; JSON.stringify(body) }, { regex: /^text\\/plain$/, serializer: ({ body }) =&gt; body } ], defaultContentType: 'application/json' }) ) .handler(lambdaHandler) const event = { headers: { Accept: 'application/xml;q=0.9, text/x-dvi; q=0.8, text/x-c' } } handler(event, {}, (_, response) =&gt; { equal(response.body, '&lt;message&gt;Hello World&lt;/message&gt;') })  ","version":"Next","tagName":"h2"},{"title":"http-urlencode-path-parser","type":0,"sectionRef":"#","url":"/docs/middlewares/http-urlencode-path-parser","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-urlencode-path-parser","url":"/docs/middlewares/http-urlencode-path-parser#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-urlencode-path-parser   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-urlencode-path-parser","url":"/docs/middlewares/http-urlencode-path-parser#options","content":" None  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-urlencode-path-parser","url":"/docs/middlewares/http-urlencode-path-parser#sample-usage","content":" import middy from '@middy/core' import httpUrlEncodePathParser from '@middy/http-urlencode-path-parser' const handler = middy((event, context) =&gt; { return event.body // propagates the body as response }) handler.use(httpUrlEncodePathParser()) // When Lambda runs the handler with a sample event... const event = { pathParameters: { name: encodeURIComponent('Mîddy') } } handler(event, {}, (_, body) =&gt; { deepEqual(body, { name: 'Mîddy' }) })  ","version":"Next","tagName":"h2"},{"title":"input-output-logger","type":0,"sectionRef":"#","url":"/docs/middlewares/input-output-logger","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"input-output-logger","url":"/docs/middlewares/input-output-logger#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/input-output-logger   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"input-output-logger","url":"/docs/middlewares/input-output-logger#options","content":" logger function (default console.log): logging function that accepts an objectawsContext boolean (default false): Include AWS Lambda context object to the loggeromitPaths string[] (default []): property accepts an array of paths that will be used to remove particular fields import the logged objects. This could serve as a simple way to redact sensitive data from logs (default []). Examples: name, user.name, users.[].namemask string: String to replace omitted values with. Example: ***omitted***  Note: If using with { streamifyResponse: true }, your ReadableStream must be of type string.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"input-output-logger","url":"/docs/middlewares/input-output-logger#sample-usage","content":" import middy from '@middy/core' import inputOutputLogger from '@middy/input-output-logger' const lambdaHandler = (event, context) =&gt; { const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) } return response } export const handler = middy().use(inputOutputLogger()).handler(lambdaHandler)   import middy from '@middy/core' import inputOutputLogger from '@middy/input-output-logger' import pino from 'pino' const logger = pino() const lambdaHandler = (event, context) =&gt; { // ... return response } export const handler = middy() .use( inputOutputLogger({ logger: (request) =&gt; { const child = logger.child(request.context) child.info(request.event ?? request.response) }, awsContext: true }) ) .handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"http-urlencode-body-parser","type":0,"sectionRef":"#","url":"/docs/middlewares/http-urlencode-body-parser","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-urlencode-body-parser","url":"/docs/middlewares/http-urlencode-body-parser#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-urlencode-body-parser   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-urlencode-body-parser","url":"/docs/middlewares/http-urlencode-body-parser#options","content":" disableContentTypeError (boolean) (optional): Skip throwing 415 when Content-Type is invalid. Default: false.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-urlencode-body-parser","url":"/docs/middlewares/http-urlencode-body-parser#sample-usage","content":" import middy from '@middy/core' import httpHeaderNormalizer from '@middy/http-header-normalizer' import httpUrlEncodeBodyParser from '@middy/http-urlencode-body-parser' const lambdaHandler = (event, context) =&gt; { return event.body // propagates the body as response } export const handler = middy() .use(httpHeaderNormalizer()) .use(httpUrlEncodeBodyParser()) .handler(lambdaHandler) // When Lambda runs the handler with a sample event... const event = { headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: 'frappucino=muffin&amp;goat%5B%5D=scone&amp;pond=moose' } handler(event, {}, (_, body) =&gt; { deepEqual(body, { frappucino: 'muffin', 'goat[]': 'scone', pond: 'moose' }) })  ","version":"Next","tagName":"h2"},{"title":"rds-signer","type":0,"sectionRef":"#","url":"/docs/middlewares/rds-signer","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"rds-signer","url":"/docs/middlewares/rds-signer#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/rds-signer npm install --save-dev @aws-sdk/rds-signer   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"rds-signer","url":"/docs/middlewares/rds-signer#options","content":" AwsClient (object) (default Signer): Signer class constructor (i.e. that has been instrumented with AWS XRay). Must be from @aws-sdk/rds-signer.awsClientOptions (object) (optional): Options to pass to Signer class constructor.fetchData (object) (required): Mapping of internal key name to API request parameters.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default rds-signer): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store role tokens to request.context.  NOTES:  Lambda is required to have IAM permission for rds-db:connect with a resource like arn:aws:rds-db:#{AWS::Region}:#{AWS::AccountId}:dbuser:${database_resource}/${iam_role}  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"rds-signer","url":"/docs/middlewares/rds-signer#sample-usage","content":" import middy from '@middy/core' import rdsSigner from '@middy/rds-signer' const lambdaHandler = (event, context) =&gt; { const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) } return response } export const handler = middy() .use( rdsSigner({ fetchData: { rdsToken: { region: 'ca-central-1', hostname: '***.rds.amazonaws.com', username: 'iam_role', port: 5432 } } }) ) .handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Bundling​","type":1,"pageTitle":"rds-signer","url":"/docs/middlewares/rds-signer#bundling","content":" To exclude @aws-sdk add @aws-sdk/rds-signer to the exclude list. ","version":"Next","tagName":"h2"},{"title":"s3-object-response","type":0,"sectionRef":"#","url":"/docs/middlewares/s3-object-response","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"s3-object-response","url":"/docs/middlewares/s3-object-response#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/s3-object-response npm install --save-dev @aws-sdk/client-s3   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"s3-object-response","url":"/docs/middlewares/s3-object-response#options","content":" AwsClient (object) (default S3Client): S3Client class constructor (i.e. that has been instrumented with AWS XRay). Must be from @aws-sdk/client-s3.awsClientOptions (object) (optional): Options to pass to S3Client class constructor.awsClientCapture (function) (optional): Enable XRay by passing captureAWSv3Client from aws-xray-sdk in.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.  NOTES:  The response from the handler must match the allowed parameters for S3.writeGetObjectResponse, excluding RequestRoute and RequestToken.XRay doesn't support tracing of fetch, you will need a workaround, see https://github.com/aws/aws-xray-sdk-node/issues/531#issuecomment-1378562164Lambda is required to have IAM permission for s3-object-lambda:WriteGetObjectResponse  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"s3-object-response","url":"/docs/middlewares/s3-object-response#sample-usage","content":" ","version":"Next","tagName":"h2"},{"title":"Stream​","type":1,"pageTitle":"s3-object-response","url":"/docs/middlewares/s3-object-response#stream","content":" import zlib from 'zlib' import middy from '@middy/core' import s3ObjectResponse from '@middy/s3-object-response' import {captureFetchGlobal} from 'aws-xray-sdk-fetch' captureFetchGlobal(true) // Enable XRay const lambdaHandler = (event, context) =&gt; { const readStream = await context.s3ObjectFetch.then(res =&gt; res.body) const transformStream = zlib.createBrotliCompress() return { Body: readStream.pipe(transformStream) } } export const handler = middy().use(s3ObjectResponse()).handler(lambdaHandler)   ","version":"Next","tagName":"h3"},{"title":"JSON​","type":1,"pageTitle":"s3-object-response","url":"/docs/middlewares/s3-object-response#json","content":" import zlib from 'zlib' import middy from '@middy/core' import s3ObjectResponse from '@middy/s3-object-response' const lambdaHandler = async (event, context) =&gt; { let body = await context.s3ObjectFetch.then((res) =&gt; res.json()) // change body return { Body: JSON.stringify(body) } } export const handler = middy().use(s3ObjectResponse()).handler(lambdaHandler)   ","version":"Next","tagName":"h3"},{"title":"Bundling​","type":1,"pageTitle":"s3-object-response","url":"/docs/middlewares/s3-object-response#bundling","content":" To exclude @aws-sdk add @aws-sdk/client-s3 to the exclude list. ","version":"Next","tagName":"h2"},{"title":"Official middlewares","type":0,"sectionRef":"#","url":"/docs/middlewares/intro","content":"","keywords":"","version":"Next"},{"title":"Misc​","type":1,"pageTitle":"Official middlewares","url":"/docs/middlewares/intro#misc","content":" cloudwatch-metrics: Hydrates lambda's context.metrics property with an instance of AWS MetricLoggerdo-not-wait-for-empty-event-loop: Sets callbackWaitsForEmptyEventLoop property to falseerror-logger: Logs errorsinput-output-logger: Logs request and responsewarmup: Used to pre-warm a lambda function  ","version":"Next","tagName":"h2"},{"title":"Request Transformation​","type":1,"pageTitle":"Official middlewares","url":"/docs/middlewares/intro#request-transformation","content":" event-normalizer: Middleware for iterating through an AWS event records, parsing and normalizing nested events.http-content-negotiation: Parses Accept-* headers and provides utilities for content negotiation (charset, encoding, language and media type) for HTTP requestshttp-event-normalizer: Normalizes HTTP events by adding an empty object for queryStringParameters, multiValueQueryStringParameters or pathParameters if they are missing.http-header-normalizer: Normalizes HTTP header names to their canonical formathttp-json-body-parser: Automatically parses HTTP requests with JSON body and converts the body into an object. Also handles gracefully broken JSON if used in combination ofhttpErrorHandler.http-multipart-body-parser: Automatically parses HTTP requests with content type multipart/form-data and converts the body into an object.http-urlencode-body-parser: Automatically parses HTTP requests with URL encoded body (typically the result of a form submit).http-urlencode-path-parser: Automatically parses HTTP requests with URL encoded path.validator: Automatically validates incoming events and outgoing responses against custom schemas.ws-json-body-parser: Automatically parses WebSocket requests with JSON message and converts the message into an object.  ","version":"Next","tagName":"h2"},{"title":"Response Transformation​","type":1,"pageTitle":"Official middlewares","url":"/docs/middlewares/intro#response-transformation","content":" http-content-encoding: Sets HTTP Content-Encoding header on response and compresses response bodyhttp-cors: Sets HTTP CORS headers on responsehttp-error-handler: Creates a proper HTTP response for errors that are created with the http-errors module and represents proper HTTP errors.http-security-headers: Applies best practice security headers to responses. It's a simplified port of HelmetJS.http-partial-response: Filter response objects attributes based on query string parameters.http-response-serializer: HTTP response serializer.sqs-partial-batch-failure: Handles partially failed SQS batches.ws-response: Forwards response to WebSocket endpoint.  ","version":"Next","tagName":"h2"},{"title":"Fetch Data​","type":1,"pageTitle":"Official middlewares","url":"/docs/middlewares/intro#fetch-data","content":" appconfig: Fetch JSON configurations from AppConfig.dynamodb: Fetch configurations from DynamoDB.rds-signer: Fetches token for connecting to RDS with IAM users.s3: Fetch JSON configurations from S3.s3-object-response: Gets and write S3 object response.secrets-manager: Fetches parameters from AWS Secrets Manager.service-discovery: Fetches Service Discovery instances to be used when connecting to other AWS services.ssm: Fetches parameters from AWS Systems Manager Parameter Store.sts: Fetches credentials to assumes IAM roles for connection to other AWS services. ","version":"Next","tagName":"h2"},{"title":"s3","type":0,"sectionRef":"#","url":"/docs/middlewares/s3","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"s3","url":"/docs/middlewares/s3#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/s3 npm install --save-dev @aws-sdk/client-s3   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"s3","url":"/docs/middlewares/s3#options","content":" AwsClient (object) (default S3Client): S3Client class constructor (i.e. that has been instrumented with AWS XRay). Must be from @aws-sdk/client-appconfig.awsClientOptions (object) (default undefined): Options to pass to S3Client class constructor.awsClientAssumeRole (string) (default undefined): Internal key where secrets are stored. See @middy/sts on to set this.awsClientCapture (function) (default undefined): Enable XRay by passing captureAWSv3Client from aws-xray-sdk in.fetchData (object) (required): Mapping of internal key name to API request parameters.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default s3): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store credentials to request.context.  NOTES:  Lambda is required to have IAM permission for s3:GetObjectIf the file is stored without ContentType, you can set it on the response using ResponseContentType as part of the input  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"s3","url":"/docs/middlewares/s3#sample-usage","content":" import middy from '@middy/core' import s3 from '@middy/s3' const lambdaHandler = (event, context) =&gt; { console.log(context.config) const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) } return response } export const handler = middy() .use( s3({ fetchData: { config: { Bucket: '...', Key: '...' } }, setToContext: true }) ) .handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Bundling​","type":1,"pageTitle":"s3","url":"/docs/middlewares/s3#bundling","content":" To exclude @aws-sdk add @aws-sdk/client-s3 to the exclude list.  ","version":"Next","tagName":"h2"},{"title":"Usage with TypeScript​","type":1,"pageTitle":"s3","url":"/docs/middlewares/s3#usage-with-typescript","content":" Data in an S3 object can be stored as arbitrary structured data. It's not possible to know in advance what shape the fetched data will have, so by default the fetched parameters will have type unknown.  You can provide some type hints by leveraging the s3Req utility function. This function allows you to specify what's the expected type that will be fetched for every S3 request.  The idea is that, for every request specified in the fetchData option, rather than just providing the parameter configuration as an object, you can wrap it in a s3Req&lt;ParamType&gt;(config) call. Internally, s3Req is a function that will return config as received, but it allows you to use generics to provide type hints for the expected fetched value type for that request.  This way TypeScript can understand how to treat the additional data attached to the context and stored in the internal storage.  The following example illustrates how to use s3Req:  import middy from '@middy/core' import s3, { s3Req } from '@middy/s3' const handler = middy((event, context) =&gt; { console.log(context.config) const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) } return response }) handler.use( s3({ fetchData: { config: s3Req&lt;{field1: string, field2: string, field3: number}&gt;({ Bucket: '...', Key: '...' } }), setToContext: true }) ) .before(async (request) =&gt; { const data = await getInternal('config', request) // data.config.field1 (string) // data.config.field2 (string) // data.config.field3 (number) })  ","version":"Next","tagName":"h2"},{"title":"secrets-manager","type":0,"sectionRef":"#","url":"/docs/middlewares/secrets-manager","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"secrets-manager","url":"/docs/middlewares/secrets-manager#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/secrets-manager npm install --save-dev @aws-sdk/client-secrets-manager   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"secrets-manager","url":"/docs/middlewares/secrets-manager#options","content":" AwsClient (object) (default SecretsManagerClient): SecretsManagerClient class constructor (i.e. that has been instrumented with AWS XRay). Must be from @aws-sdk/client-secrets-manager.awsClientOptions (object) (optional): Options to pass to SecretsManagerClient class constructor.awsClientAssumeRole (string) (optional): Internal key where secrets are stored. See @middy/sts on to set this.awsClientCapture (function) (optional): Enable XRay by passing captureAWSv3Client from aws-xray-sdk in.fetchData (object) (required): Mapping of internal key name to API request parameter SecretId.fetchRotationDate (boolean|object) (default false): Boolean to apply to all or mapping of internal key name to boolean. This indicates what secrets should fetch and cached based on NextRotationDate/LastRotationDate/LastChangedDate. cacheExpiry of -1 will use NextRotationDate, while any other value will be added to the LastRotationDate or LastChangedDate, whichever is more recent. If secrets have different rotation schedules, use multiple instances of this middleware.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default secrets-manager): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store secrets to request.context.  NOTES:  Lambda is required to have IAM permission for secretsmanager:GetSecretValue. If using fetchRotationDate add secretsmanager:DescribeSecret in as well.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"secrets-manager","url":"/docs/middlewares/secrets-manager#sample-usage","content":" import middy from '@middy/core' import secretsManager from '@middy/secrets-manager' const lambdaHandler = (event, context) =&gt; { return {} } export const handler = middy() .use( secretsManager({ fetchData: { apiToken: 'dev/api_token' }, awsClientOptions: { region: 'us-east-1' }, setToContext: true }) ) .handler(lambdaHandler) // Before running the function handler, the middleware will fetch from Secrets Manager handler(event, context, (_, response) =&gt; { // assuming the dev/api_token has two keys, 'Username' and 'Password' equal(context.apiToken.Username, 'username') equal(context.apiToken.Password, 'password') })   ","version":"Next","tagName":"h2"},{"title":"Bundling​","type":1,"pageTitle":"secrets-manager","url":"/docs/middlewares/secrets-manager#bundling","content":" To exclude @aws-sdk add @aws-sdk/client-secrets-manager to the exclude list.  ","version":"Next","tagName":"h2"},{"title":"Usage with TypeScript​","type":1,"pageTitle":"secrets-manager","url":"/docs/middlewares/secrets-manager#usage-with-typescript","content":" Data stored in SecretsManager can be stored as arbitrary structured data. It's not possible to know in advance what shape the fetched data will have, so by default the fetched secrets will have type unknown.  You can provide some type hints by leveraging the secret utility function. This function allows you to specify what's the expected type that will be fetched for every SecretsManager request.  The idea is that, for every request specified in the fetchData option, rather than just providing the parameter configuration as an object, you can wrap it in a secret&lt;ParamType&gt;(key) call. Internally, secret is a function that will return key as received, but it allows you to use generics to provide type hints for the expected fetched value type for that request.  This way TypeScript can understand how to treat the additional data attached to the context and stored in the internal storage.  The following example illustrates how to use secret:  import middy from '@middy/core' import secretsManager, { secret } from '@middy/secrets-manager' const lambdaHandler = (event, context) =&gt; { console.log(context.config) const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) } return response } export const handler = middy() .use( secretsManager({ fetchData: { someSecret: secret&lt;{User: string, Password: string}&gt;('someHiddenSecret') }), setToContext: true }) ) .before(async (request) =&gt; { const data = await getInternal('someSecret', request) // data.someSecret.User (string) // data.someSecret.Password (string) // or, since we have `setToContext: true` // request.context.someSecret.User (string) // request.context.someSecret.Password (string) }) .handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"service-discovery","type":0,"sectionRef":"#","url":"/docs/middlewares/service-discovery","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"service-discovery","url":"/docs/middlewares/service-discovery#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/service-discovery npm install --save-dev @aws-sdk/client-servicediscovery   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"service-discovery","url":"/docs/middlewares/service-discovery#options","content":" AwsClient (object) (default ServiceDiscoveryClient): ServiceDiscoveryClient class constructor (i.e. that has been instrumented with AWS XRay). Must be from @aws-sdk/client-servicediscovery.awsClientOptions (object) (default undefined): Options to pass to ServiceDiscoveryClient class constructor.awsClientAssumeRole (string) (default undefined): Internal key where secrets are stored. See @middy/sts on to set this.awsClientCapture (function) (default undefined): Enable XRay by passing captureAWSv3Client from aws-xray-sdk in.fetchData (object) (required): Mapping of internal key name to API request parameters.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default sts): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store credentials to request.context.  NOTES:  Lambda is required to have IAM permission for servicediscovery:DiscoverInstances  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"service-discovery","url":"/docs/middlewares/service-discovery#sample-usage","content":" import middy from '@middy/core' import serviceDiscovery from '@middy/service-discovery' const lambdaHandler = (event, context) =&gt; { const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) } return response } export const handler = middy() .use( serviceDiscovery({ fetchData: { instances: { NamespaceName: '...', ServiceName: '...' } } }) ) .handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Bundling​","type":1,"pageTitle":"service-discovery","url":"/docs/middlewares/service-discovery#bundling","content":" To exclude @aws-sdk add @aws-sdk/client-servicediscovery to the exclude list. ","version":"Next","tagName":"h2"},{"title":"sqs-partial-batch-failure","type":0,"sectionRef":"#","url":"/docs/middlewares/sqs-partial-batch-failure","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"sqs-partial-batch-failure","url":"/docs/middlewares/sqs-partial-batch-failure#install","content":" To install this middleware, you can use NPM:  npmYarnpnpmBun npm install --save @middy/sqs-partial-batch-failure # Required for types only npm install --save-dev @aws-sdk/client-sqs   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"sqs-partial-batch-failure","url":"/docs/middlewares/sqs-partial-batch-failure#options","content":" logger (function) (optional): A function that will be called when a record fails to be processed. Default: console.error  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"sqs-partial-batch-failure","url":"/docs/middlewares/sqs-partial-batch-failure#sample-usage","content":" Parallel processing example (works for Standard queues and FIFO queues when ordering of side‑effects is not required):  import middy from '@middy/core' import sqsBatch from '@middy/sqs-partial-batch-failure' const lambdaHandler = async (event) =&gt; { return Promise.allSettled( event.Records.map(async (record) =&gt; { await processMessageAsync(record); }) ); }; export const handler = middy().use(sqsBatch()).handler(lambdaHandler);   With TypeScript:  import middy from '@middy/core' import sqsBatch from '@middy/sqs-partial-batch-failure' const lambdaHandler = async (event: SQSEvent): Promise&lt;PromiseSettledResult&lt;unknown&gt;[]&gt; =&gt; { return Promise.allSettled( event.Records.map(async (record) =&gt; { await processMessageAsync(record); }) ); }; export const handler = middy().use(sqsBatch()).handler(lambdaHandler);   FIFO queue example (preserves processing order):  import middy from '@middy/core' import sqsBatch from '@middy/sqs-partial-batch-failure' const lambdaHandler = (event, context) =&gt; { const statusPromises = []; for (const [idx, record] of Object.entries(Records)) { try { await processMessageAsync(record) statusPromises.push(Promise.resolve()); } catch (error) { statusPromises.push(Promise.reject(error)); } } return Promise.allSettled(statusPromises); } export const handler = middy().use(sqsBatch()).handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Important​","type":1,"pageTitle":"sqs-partial-batch-failure","url":"/docs/middlewares/sqs-partial-batch-failure#important","content":" This middleware only works if the handler returns an array of PromiseSettledResults (typically from Promise.allSettled() or a sequential loop that builds the same structure). If you manually return { batchItemFailures }, do not use this middleware.  The value ReportBatchItemFailures must be added to your Lambda's FunctionResponseTypes in the EventSourceMapping configuration. See Reporting batch item failures and Lambda EventSourceMapping ","version":"Next","tagName":"h2"},{"title":"sts","type":0,"sectionRef":"#","url":"/docs/middlewares/sts","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"sts","url":"/docs/middlewares/sts#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/sts npm install --save-dev @aws-sdk/client-sts   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"sts","url":"/docs/middlewares/sts#options","content":" AwsClient (object) (default STSClient): STSClient class constructor (i.e. that has been instrumented with AWS XRay). Must be from @aws-sdk/client-sts.awsClientOptions (object) (optional): Options to pass to STSClient class constructor.awsClientCapture (function) (optional): Enable XRay by passing captureAWSv3Client from aws-xray-sdk in.fetchData (object) (required): Mapping of internal key name to API request parameters.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default sts): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store credentials to request.context.  NOTES:  Lambda is required to have IAM permission for sts:AssumeRolesetToContext are included for legacy support and should be avoided for performance and security reasons. See main documentation for best practices.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"sts","url":"/docs/middlewares/sts#sample-usage","content":" import middy from '@middy/core' import sts from '@middy/sts' const lambdaHandler = (event, context) =&gt; { const response = { statusCode: 200, headers: {}, body: JSON.stringify({ message: 'hello world' }) } return response } export const handler = middy() .use( sts({ fetchData: { assumeRole: { RoleArn: '...', RoleSessionName: '' // optional } } }) ) .handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Bundling​","type":1,"pageTitle":"sts","url":"/docs/middlewares/sts#bundling","content":" To exclude @aws-sdk add @aws-sdk/client-sts to the exclude list. ","version":"Next","tagName":"h2"},{"title":"Third-party middlewares","type":0,"sectionRef":"#","url":"/docs/middlewares/third-party","content":"","keywords":"","version":"Next"},{"title":"Version 2.x - 5.x​","type":1,"pageTitle":"Third-party middlewares","url":"/docs/middlewares/third-party#version-2x---5x","content":" dazn-lambda-powertools: A collection of middlewares, AWS clients and helper libraries that make working with lambda easier.middy-ajv: AJV validator optimized for performancemiddy-console-logger: Middleware for filtering logs printed over console logging methods. If the level of the console logging method is equal or bigger than configured level, the log is printed, Otherwise, it is ignored.middy-event-loop-tracer: Middleware for dumping active tasks with their stacktraces in the event queue just before AWS Lambda function timeouts. So you can understand what was going on in the function when timeout happens.middy-idempotent: idempotency middleware for middymiddy-invocation: Middleware for accessing current AWS Lambda invocation event and context from anywhere without need to passing event and context as arguments through your code.- middy-lesslog: Middleware for lesslog, a teeny-tiny and severless-ready logging utilitymiddy-jsonapi: JSONAPI middleware for middymiddy-lesslog: Middleware for lesslog, a teeny-tiny and severless-ready logging utilitymiddy-profiler: Middleware for profiling CPU on AWS Lambda during invocation and shows what methods/modules consume what percent of CPU timemiddy-rds: Creates RDS connection using knex or pgmiddy-recaptcha: reCAPTCHA validation middlewaremiddy-sparks-joi: Joi validatormiddy-store: Middleware to automatically store and load payloads from S3 in an AWS Step Functions state machinemiddy-mcp: Middleware for Model Context Protocol (MCP) server integration with AWS Lambda functions@iress/middy-http-path-router: Routes AWS API Gateway events to handlers based on static and dynamic paths@nhs/fhir-middy-error-handler: An error handler for use in an AWS Lambda returning FHIR compliant error messages as OperationOutcome resources. Used as part of the Prescriptions for Patients FHIR API.  ","version":"Next","tagName":"h2"},{"title":"Version 2.x - 3.x​","type":1,"pageTitle":"Third-party middlewares","url":"/docs/middlewares/third-party#version-2x---3x","content":" aws-lambda-powertools-typescript: A suite of utilities for AWS Lambda Functions that makes structured logging, creating custom metrics asynchronously and tracing with AWS X-Ray easier logger: Structured logging made easier, and a middleware to enrich log items with key details of the Lambda contextmetrics: Custom Metrics created asynchronously via CloudWatch Embedded Metric Format (EMF)parameters: The Parameters utility provides high-level functions to retrieve one or multiple parameter values from AWS Systems Manager Parameter Store, AWS Secrets Manager, AWS AppConfig, Amazon DynamoDB, or your own parameter store.tracer: Utilities to trace Lambda function handlers, and both synchronous and asynchronous functions  ","version":"Next","tagName":"h2"},{"title":"Version 1.x​","type":1,"pageTitle":"Third-party middlewares","url":"/docs/middlewares/third-party#version-1x","content":" middy-redis: Redis connection middlewaremiddy-extractor: Extracts data from events using expressions@keboola/middy-error-logger: middleware that catches thrown exceptions and rejected promises and logs them comprehensibly to the console@keboola/middy-event-validator: Joi powered event validation middlewaremiddy-reroute: provides complex redirect, rewrite and proxying capabilities by simply placing a rules file into your S3 bucketmiddytohof: Convert Middy middleware plugins to higher-order functions returning lambda handlerswrap-ware: A middleware wrapper which works with promises / asyncmiddy-middleware-warmup: A middy plugin to help keep your Lambdas warm during Winter@sharecover-co/middy-aws-xray-tracing: AWS X-Ray Tracing Middleware@sharecover-co/middy-http-response-serializer: This middleware serializes the response to JSON and wraps it in a 200 HTTP response@seedrs/middyjs-middleware: Collection of useful middlewaresmiddy-autoproxyresponse: A middleware that lets you return simple JavaScript objects from Lambda function handlers and converts them into LAMBDA_PROXY responsesjwt-auth: JSON web token authorization middleware based on express-jwtmiddy-mongoose-connector: MongoDB connection middleware for mongoose.js@ematipico/middy-request-response: a middleware that creates a pair of request/response objects@marcosantonocito/middy-cognito-permission: Authorization and roles permission management for the Middy framework that works with Amazon Cognitomiddy-env: Fetch, validate and type cast environment variablessqs-json-body-parser: Parse the SQS body to JSONmiddy-lesslog: Middleware for lesslog, a teeny-tiny and severless-ready logging utility ","version":"Next","tagName":"h2"},{"title":"ssm","type":0,"sectionRef":"#","url":"/docs/middlewares/ssm","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"ssm","url":"/docs/middlewares/ssm#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/ssm npm install --save-dev @aws-sdk/client-ssm   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"ssm","url":"/docs/middlewares/ssm#options","content":" AwsClient (object) (default SSMClient): SSMClient class constructor (i.e. that has been instrumented with AWS X-Ray). Must be from @aws-sdk/client-ssm.awsClientOptions (object) (optional): Options to pass to SSMClient class constructor.awsClientAssumeRole (string) (optional): Internal key where role tokens are stored. See @middy/sts on to set this.awsClientCapture (function) (optional): Enable AWS X-Ray by passing captureAWSv3Client from aws-xray-sdk in.fetchData (object) (required): Mapping of internal key name to API request parameter Names/Path. SecureString are automatically decrypted.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.cacheKey (string) (default ssm): Cache key for the fetched data responses. Must be unique across all middleware.cacheExpiry (number) (default -1): How long fetch data responses should be cached for. -1: cache forever, 0: never cache, n: cache for n ms.setToContext (boolean) (default false): Store role tokens to request.context.  NOTES:  Lambda is required to have IAM permission for ssm:GetParameters and/or ssm:GetParametersByPath depending on what you're requesting, along with kms:Decrypt.SSM has throughput limitations. Switching to Advanced Parameter type or increasing maxRetries and retryDelayOptions.base in awsClientOptions may be required.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"ssm","url":"/docs/middlewares/ssm#sample-usage","content":" import middy from '@middy/core' import ssm from '@middy/ssm' const lambdaHandler = (event, context) =&gt; { return {} } let globalDefaults = {} export const handler = middy() .use( ssm({ fetchData: { accessToken: '/dev/service_name/access_token', // single value dbParams: '/dev/service_name/database/', // object of values, key for each path defaults: '/dev/defaults' }, setToContext: true }) ) .before((request) =&gt; { globalDefaults = request.context.defaults.global }) .handler(lambdaHandler)   import middy from '@middy/core' import { getInternal } from '@middy/util' import ssm from '@middy/ssm' const lambdaHandler = (event, context) =&gt; { return {} } let globalDefaults = {} export const handler = middy() .use( ssm({ fetchData: { defaults: '/dev/defaults' }, cacheKey: 'ssm-defaults' }) ) .use( ssm({ fetchData: { accessToken: '/dev/service_name/access_token', // single value dbParams: '/dev/service_name/database/' // object of values, key for each path }, cacheExpiry: 15 * 60 * 1000, cacheKey: 'ssm-secrets' }) ) // ... other middleware that fetch .before(async (request) =&gt; { const data = await getInternal( ['accessToken', 'dbParams', 'defaults'], request ) Object.assign(request.context, data) }) .handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Bundling​","type":1,"pageTitle":"ssm","url":"/docs/middlewares/ssm#bundling","content":" To exclude @aws-sdk add @aws-sdk/client-ssm to the exclude list.  ","version":"Next","tagName":"h2"},{"title":"Usage with TypeScript​","type":1,"pageTitle":"ssm","url":"/docs/middlewares/ssm#usage-with-typescript","content":" Data in SSM can be stored as arbitrary JSON values. It's not possible to know in advance what shape the fetched SSM parameters will have, so by default the fetched parameters will have type unknown.  You can provide some type hints by leveraging the ssmParam utility function. This function allows you to specify what's the expected type that will be fetched for every parameter.  The idea is that, for every parameter specified in the fetchData option, rather than just providing the parameter path as a string, you can wrap it in a ssmParam&lt;ParamType&gt;(parameterPath) call. Internally, ssmParam is a function that will return parameterPath as received, but it allows you to use generics to provide type hints for the expected type for that parameter.  This way TypeScript can understand how to treat the additional data attached to the context and stored in the internal storage.  The following example illustrates how to use ssmParam:  import middy from '@middy/core' import { getInternal } from '@middy/util' import ssm, { ssmParam } from '@middy/ssm' const lambdaHandler = (event, context) =&gt; { return {} } let globalDefaults = {} export const handler = middy() .use( ssm({ fetchData: { accessToken: ssmParam&lt;string&gt;('/dev/service_name/access_token'), // single value (will be typed as string) dbParams: ssmParam&lt;{ user: string; pass: string }&gt;( '/dev/service_name/database/' ) // object of values (typed as {user: string, pass: string}) }, cacheExpiry: 15 * 60 * 1000, cacheKey: 'ssm-secrets' }) ) // ... other middleware that fetch .before(async (request) =&gt; { const data = await getInternal(['accessToken', 'dbParams'], request) // data.accessToken (string) // data.dbParams ({user: string, pass: string}) }) .handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"warmup","type":0,"sectionRef":"#","url":"/docs/middlewares/warmup","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"warmup","url":"/docs/middlewares/warmup#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/warmup   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"warmup","url":"/docs/middlewares/warmup#options","content":" isWarmingUp: a function that accepts the event object as a parameter and returns true if the current event is a warmup event and false if it's a regular execution. The default function will check if the event object has a source property set to serverless-plugin-warmup.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"warmup","url":"/docs/middlewares/warmup#sample-usage","content":" const middy = require('@middy/core') const warmup = require('@middy/warmup') const lambdaHandler = (event, context, cb) =&gt; { /* ... */ } const isWarmingUp = (event) =&gt; event.isWarmingUp === true export const handler = middy() .use(warmup({ isWarmingUp })) .handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"ws-json-body-parser","type":0,"sectionRef":"#","url":"/docs/middlewares/ws-json-body-parser","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"ws-json-body-parser","url":"/docs/middlewares/ws-json-body-parser#install","content":" To install this middleware you can use NPM:  npm install --save @middy/ws-json-body-parser   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"ws-json-body-parser","url":"/docs/middlewares/ws-json-body-parser#options","content":" reviver (function) (default undefined): A reviver parameter may be passed which will be used JSON.parseing the body.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"ws-json-body-parser","url":"/docs/middlewares/ws-json-body-parser#sample-usage","content":" import middy from '@middy/core' import wsJsonBodyParserMiddleware from '@middy/ws-json-body-parser' import wsResponseMiddleware from '@middy/ws-response' const lambdaHandler = (event) =&gt; { return event.body.message } export const handler = middy() .use(wsJsonBodyParserMiddleware()) .use(wsResponseMiddleware()) .handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"cloudformation-router","type":0,"sectionRef":"#","url":"/docs/routers/cloudformation-router","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"cloudformation-router","url":"/docs/routers/cloudformation-router#install","content":" To install this middleware you can use NPM:  npm install --save @middy/cloudformation-router   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"cloudformation-router","url":"/docs/routers/cloudformation-router#options","content":" routes (array[{routeKey, handler}]) (required): Array of route objects. routeKey (string) (required): AWS formatted request type. ie Create, Update, Deletehandler (function) (required): Any handler(event, context, {signal}) function notFoundHandler (function): Override default FAILED response with your own custom response. Passes in {requestType}  NOTES:  Reponse parameters are automatically applied for Status, RequestId, LogicalResourceId, and/or StackId when not present.Errors should be handled as part of the router middleware stack or the lambdaHandler middleware stack. Handled errors in the later will trigger the after middleware stack of the former.Shared middlewares, connected to the router middleware stack, can only be run before the lambdaHandler middleware stack.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"cloudformation-router","url":"/docs/routers/cloudformation-router#sample-usage","content":" import middy from '@middy/core' import cloudformationRouterHandler from '@middy/cloudformation-router' import cloudformationResponseMiddleware from '@middy/cloudformation-response' import validatorMiddleware from '@middy/validator' const createHandler = middy() .use(validatorMiddleware({eventSchema: {...} })) .handler((event, context) =&gt; { return { PhysicalResourceId: '...', Data:{} } }) const updateHandler = middy() .use(validatorMiddleware({eventSchema: {...} })) .handler((event, context) =&gt; { return { PhysicalResourceId: '...', Data: {} } }) const deleteHandler = middy() .use(validatorMiddleware({eventSchema: {...} })) .handler((event, context) =&gt; { return { PhysicalResourceId: '...' } }) const routes = [ { requesType: 'Create', handler: createHandler }, { requesType: 'Update', handler: updateHandler }, { routeKey: 'Delete', handler: deleteHandler } ] export const handler = middy() .use(cloudformationResponseMiddleware()) .handler(cloudformationRouterHandler(routes))  ","version":"Next","tagName":"h2"},{"title":"ws-response","type":0,"sectionRef":"#","url":"/docs/middlewares/ws-response","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"ws-response","url":"/docs/middlewares/ws-response#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/ws-response npm install --save-dev @aws-sdk/client-apigatewaymanagementapi   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"ws-response","url":"/docs/middlewares/ws-response#options","content":" AwsClient (object) (default ApiGatewayManagementApiClient): ApiGatewayManagementApi class constructor (i.e. that has been instrumented with AWS XRay). Must be from @aws-sdk/client-apigatewaymanagementapi.awsClientOptions (object) (default undefined): Options to pass to ApiGatewayManagementApiClient class constructor.awsClientAssumeRole (string) (default undefined): Internal key where secrets are stored. See @middy/sts on to set this.awsClientCapture (function) (default undefined): Enable XRay by passing captureAWSv3Client from aws-xray-sdk in.disablePrefetch (boolean) (default false): On cold start requests will trigger early if they can. Setting awsClientAssumeRole disables prefetch.  NOTES:  Lambda is required to have IAM permission for execute-api:ManageConnectionsIf awsClientOptions.endpoint is not set it will be set using event.requestContext.{domainName,stage}If response does not contain ConnectId, it will be set from event.requestContext.connectionId  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"ws-response","url":"/docs/middlewares/ws-response#sample-usage","content":" ","version":"Next","tagName":"h2"},{"title":"API Gateway​","type":1,"pageTitle":"ws-response","url":"/docs/middlewares/ws-response#api-gateway","content":" import middy from '@middy/core' import wsResponse from '@middy/ws-response' export const handler = middy((event, context) =&gt; { return 'message' }) handler.use(wsResponse())   ","version":"Next","tagName":"h3"},{"title":"General​","type":1,"pageTitle":"ws-response","url":"/docs/middlewares/ws-response#general","content":" import middy from '@middy/core' import wsResponse from '@middy/ws-response' const lambdaHandler = (event, context) =&gt; { return { ConnectionId: '...', Data: 'message' } } export const handler = middy() .use( wsResponse({ awsClientOptions: { endpoint: '...' } }) ) .handler(lambdaHandler)   ","version":"Next","tagName":"h3"},{"title":"Bundling​","type":1,"pageTitle":"ws-response","url":"/docs/middlewares/ws-response#bundling","content":" To exclude @aws-sdk add @aws-sdk/client-apigatewaymanagementapi to the exclude list. ","version":"Next","tagName":"h2"},{"title":"validator","type":0,"sectionRef":"#","url":"/docs/middlewares/validator","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"validator","url":"/docs/middlewares/validator#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/validator npm install --save-dev ajv-cmd # Optional: for pre-transpiling   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"validator","url":"/docs/middlewares/validator#options","content":" eventSchema (function) (default undefined): The compiled ajv validator that will be used to validate the input (request.event) of the Lambda handler.contextSchema (function) (default undefined): The compiled ajv validator that will be used to validate the input (request.context) of the Lambda handler. Has additional support for typeof keyword to allow validation of &quot;typeof&quot;:&quot;function&quot;.responseSchema (function) (default undefined): The compiled ajv validator that will be used to validate the output (request.response) of the Lambda handler.i18nEnabled (boolean) (default true): Option to disable i18n default package.defaultLanguage (string) (default en): When language not found, what language to fallback to.languages (object) (default: {}): Localization overrides  NOTES:  At least one of eventSchema or responseSchema is required.If you'd like to have the error details as part of the response, it will need to be handled separately. You can access them from request.error.cause.data, the original response can be found at request.error.response.Important Transpiling schemas &amp; locales on the fly will cause a 50-150ms performance hit during cold start for simple JSON Schemas. Precompiling is highly recommended.  ","version":"Next","tagName":"h2"},{"title":"transpileSchema​","type":1,"pageTitle":"validator","url":"/docs/middlewares/validator#transpileschema","content":" Transpile JSON-Schema in to JavaScript. Default ajv plugins used: ajv-i18n, ajv-formats, ajv-formats-draft2019, ajv-keywords, ajv-errors.  schema (object) (required): JSON-Schema objectajvOptions (object) (default undefined): Options to pass to ajvclass constructor. Defaults are { strict: true, coerceTypes: 'array', allErrors: true, useDefaults: 'empty', messages: true }.  ","version":"Next","tagName":"h2"},{"title":"transpileLocale​","type":1,"pageTitle":"validator","url":"/docs/middlewares/validator#transpilelocale","content":" Transpile Fluent (.ftl) localization file into ajv compatible format. Allows the overriding of the default messages and adds support for multi-language errrorMessages.  ftl (string) (required): Contents of an ftl file to be transpiled.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"validator","url":"/docs/middlewares/validator#sample-usage","content":" Example for event validation:  import middy from '@middy/core' import validator from '@middy/validator' import { transpileSchema } from '@middy/validator/transpile' const lambdaHandler = (event, context) =&gt; { return {} } const schema = { type: 'object', required: ['body', 'foo'], properties: { // this will pass validation body: { type: 'string' }, // this won't as it won't be in the event foo: { type: 'string' } } } export const handler = middy() .use( validator({ eventSchema: transpileSchema(schema) }) ) .handler(lambdaHandler) // invokes the handler, note that property foo is missing const event = { body: JSON.stringify({ something: 'somethingelse' }) } handler(event, {}, (err, res) =&gt; { equal(err.message, 'Event object failed validation') })   Example for response validation:  import middy from '@middy/core' import validator from '@middy/validator' import { transpileSchema } from '@middy/validator/transpile' const lambdaHandler = (event, context) =&gt; { return {} } const responseSchema = transpileSchema({ type: 'object', required: ['body', 'statusCode'], properties: { body: { type: 'object' }, statusCode: { type: 'number' } } }) export const handler = middy() .use(validator({ responseSchema })) .handler(lambdaHandler) // handler({}, {}, (err, response) =&gt; { notEqual(err, null) equal(err.message, 'Response object failed validation') expect(response).not.toBe(null) // it doesn't destroy the response so it can be used by other middlewares })   Example for body validation:  import middy from '@middy/core' import httpJsonBodyParser from '@middy/http-json-body-parser' import validator from '@middy/validator' import { transpileSchema } from '@middy/validator/transpile' const lambdaHandler = (event, context) =&gt; { return {} } const eventSchema = { type: 'object', required: ['body'], properties: { body: { type: 'object', required: ['name', 'email'], properties: { name: { type: 'string' }, email: { type: 'string', format: 'email' } // schema options https://ajv.js.org/json-schema.html#json-data-type } } } } export const handler = middy() // to validate the body we need to parse it first .use(httpJsonBodyParser()) .use( validator({ eventSchema: transpileSchema(eventSchema) }) ) .handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Pre-transpiling example (recommended)​","type":1,"pageTitle":"validator","url":"/docs/middlewares/validator#pre-transpiling-example-recommended","content":" Run a build script to before running tests &amp; deployment.  #!/usr/bin/env bash # This is an example, should be customize to meet ones needs # Powered by `ajv-cmd` # $ ajv --help bundle () { ajv validate ${1} --valid \\ --strict true --coerce-types array --all-errors true --use-defaults empty ajv transpile ${1} \\ --strict true --coerce-types array --all-errors true --use-defaults empty \\ -o ${1%.json}.js } for file in handlers/*/schema.*.json; do bundle $file done locale () { LOCALE=$(basename ${1%.ftl}) ajv ftl ${1} --locale ${LOCALE} -o ${1%.ftl}.js } for file in handlers/*/*.ftl; do locale $file done   import middy from '@middy/core' import validator from '@middy/validator' import eventSchema from './schema.event.js' import en from './en.js' import fr from './fr.js' const lambdaHandler = (event, context) =&gt; { return {} } export const handler = middy() .use( validator({ eventSchema, languages: { en, fr } }) ) .handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Transpile during cold-start​","type":1,"pageTitle":"validator","url":"/docs/middlewares/validator#transpile-during-cold-start","content":" import { readFile } from 'node:fs/promises' import middy from '@middy/core' import validator from '@middy/validator' import { transpileSchema, transpileLocale } from '@middy/validator/transpile' import eventSchema from './schema.event.json' const lambdaHandler = (event, context) =&gt; { return {} } const en = transpileLocale(await readFile('./en.ftl')) const fr = transpileLocale(await readFile('./fr.ftl')) export const handler = middy() .use( validator({ eventSchema: transpileSchema(eventSchema), languages: { en, fr } }) ) .handler(lambdaHandler)   ","version":"Next","tagName":"h2"},{"title":"Transpile during cold-start with default messages​","type":1,"pageTitle":"validator","url":"/docs/middlewares/validator#transpile-during-cold-start-with-default-messages","content":" import { readFile } from 'node:fs/promises' import middy from '@middy/core' import validator from '@middy/validator' import { transpileSchema, transpileLocale } from '@middy/validator/transpile' import { en, fr } from 'ajv-ftl-i18n' // `ajv-i18n` can also be used import eventSchema from './schema.event.json' const lambdaHandler = (event, context) =&gt; { return {} } export const handler = middy() .use( validator({ eventSchema: transpileSchema(eventSchema), languages: { en, fr } }) ) .handler(lambdaHandler)  ","version":"Next","tagName":"h2"},{"title":"ws-router","type":0,"sectionRef":"#","url":"/docs/routers/ws-router","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"ws-router","url":"/docs/routers/ws-router#install","content":" To install this middleware you can use NPM:  npm install --save @middy/ws-router   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"ws-router","url":"/docs/routers/ws-router#options","content":" routes (array[{routeKey, handler}]) (required): Array of route objects. routeKey (string) (required): AWS formatted route key. ie $connect, $disconnect, $defaulthandler (function) (required): Any handler(event, context, {signal}) function notFoundHandler (function): Override default 404 error thrown with your own custom response. Passes in {routeKey}  NOTES:  Errors should be handled as part of the router middleware stack or the lambdaHandler middleware stack. Handled errors in the later will trigger the after middleware stack of the former.Shared middlewares, connected to the router middleware stack, can only be run before the lambdaHandler middleware stack.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"ws-router","url":"/docs/routers/ws-router#sample-usage","content":" import middy from '@middy/core' import wsRouterHandler from '@middy/ws-router' import wsResponseMiddleware from '@middy/ws-response' import validatorMiddleware from '@middy/validator' const connectHandler = middy() .use(validatorMiddleware({eventSchema: {...} })) .handler((event, context) =&gt; { return 'connected' }) const disconnectHandler = middy() .use(validatorMiddleware({eventSchema: {...} })) .handler((event, context) =&gt; { return 'disconnected' }) const routes = [ { routeKey: '$connect', handler: connectHandler }, { routeKey: '$disconnect', handler: disconnectHandler } ] export const handler = middy() .use(wsResponseMiddleware()) .handler(wsRouterHandler(routes))  ","version":"Next","tagName":"h2"},{"title":"Upgrade 0.x -> 1.x","type":0,"sectionRef":"#","url":"/docs/upgrade/0-1","content":"","keywords":"","version":"Next"},{"title":"Independent packages structure​","type":1,"pageTitle":"Upgrade 0.x -> 1.x","url":"/docs/upgrade/0-1#independent-packages-structure","content":" Version 1.x of Middy features decoupled independent packages published on npm under the @middy namespace. The core middleware engine has been moved to @middy/core and all the other middlewares are moved into their own packages as well. This allows to only install the features that are needed and to keep your Lambda dependencies small. See the list below to check which packages you need based on the middlewares you use:  Core middleware functionality -&gt; @middy/corecache -&gt; @middy/cachecors -&gt; @middy/http-corsdoNotWaitForEmptyEventLoop -&gt; @middy/do-not-wait-for-empty-event-loophttpContentNegotiation -&gt; @middy/http-content-negotiationhttpErrorHandler -&gt; @middy/http-error-handlerhttpEventNormalizer -&gt; @middy/http-event-normalizerhttpHeaderNormalizer -&gt; @middy/http-header-normalizerhttpMultipartBodyParser -&gt; @middy/http-json-body-parserhttpPartialResponse -&gt; @middy/http-partial-responsejsonBodyParser -&gt; @middy/http-json-body-parsers3KeyNormalizer -&gt; @middy/s3-key-normalizersecretsManager -&gt; @middy/secrets-managerssm -&gt; @middy/ssmvalidator -&gt; @middy/validatorurlEncodeBodyParser -&gt; @middy/http-urlencode-body-parserwarmup -&gt; @middy/warmup  ","version":"Next","tagName":"h2"},{"title":"Header normalization in http-header-normalizer​","type":1,"pageTitle":"Upgrade 0.x -> 1.x","url":"/docs/upgrade/0-1#header-normalization-in-http-header-normalizer","content":" In Middy 0.x the httpHeaderNormalizer middleware normalizes HTTP header names into their own canonical format, for instance Sec-WebSocket-Key (notice the casing). In Middy 1.x this behavior has been changed to provide header names in lowercase format (e.g. sec-webSocket-key). This new behavior is more consistent with what Node.js core http package does and what other famous http frameworks like Express or Fastify do, so this is considered a more intuitive approach. When updating to Middy 1.x, make sure you double check all your references to HTTP headers and switch to the lowercase version to read them. All the middy core modules have been already updated to support the new format, so you should worry only about your userland code.  ","version":"Next","tagName":"h2"},{"title":"Node.js 10 and 12 now supported / Node.js 6 and 8 now dropped​","type":1,"pageTitle":"Upgrade 0.x -> 1.x","url":"/docs/upgrade/0-1#nodejs-10-and-12-now-supported--nodejs-6-and-8-now-dropped","content":" Version 1.x of Middy no longer supports Node.js versions 6.x and 8.x as these versions have been dropped by the AWS Lambda runtime itself and not supported anymore by the Node.js community. You are highly encouraged to move to Node.js 12 or 10, which are the new supported versions in Middy 1.x. ","version":"Next","tagName":"h2"},{"title":"http-router","type":0,"sectionRef":"#","url":"/docs/routers/http-router","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"http-router","url":"/docs/routers/http-router#install","content":" To install this middleware you can use NPM:  npmYarnpnpmBun npm install --save @middy/http-router   ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"http-router","url":"/docs/routers/http-router#options","content":" routes (array[{method, path, handler}]) (required): Array of route objects. method (string) (required): One of GET, POST, PUT, PATCH, DELETE, OPTIONS and ANY that will match to any method passed inpath (string) (required): AWS formatted path starting with /. Variable: /{id}/, Wildcard: /{proxy+}handler (function) (required): Any handler(event, context) function notFoundResponse (function): Override default 404 error thrown with your own custom response. Passes in {method, path}  NOTES:  When using API Gateway it may be required to prefix routes[].path with /{stage} depending on your use case.Errors should be handled as part of the router middleware stack or the lambdaHandler middleware stack. Handled errors in the later will trigger the after middleware stack of the former.Shared middlewares, connected to the router middleware stack, can only be run before the lambdaHandler middleware stack.pathParameters will automatically be set if not already setPath parameters in kebab notation ({my-var}) are not supported. Workaround example below.  ","version":"Next","tagName":"h2"},{"title":"Sample usage​","type":1,"pageTitle":"http-router","url":"/docs/routers/http-router#sample-usage","content":" import middy from '@middy/core' import httpRouterHandler from '@middy/http-router' import validatorMiddleware from '@middy/validator' const getHandler = middy() .use(validatorMiddleware({eventSchema: {...} })) .handler((event, context) =&gt; { return { statusCode: 200, body: '{...}' } }) const postHandler = middy() .use(validatorMiddleware({eventSchema: {...} })) .handler((event, context) =&gt; { return { statusCode: 200, body: '{...}' } }) const routes = [ { method: 'GET', path: '/user/{id}', handler: getHandler }, { method: 'POST', path: '/user', handler: postHandler } ] export const handler = middy() .use(httpHeaderNormalizer()) .handler(httpRouterHandler(routes))   ","version":"Next","tagName":"h2"},{"title":"Sample kebab usage​","type":1,"pageTitle":"http-router","url":"/docs/routers/http-router#sample-kebab-usage","content":" import middy from '@middy/core' import httpRouterHandler from '@middy/http-router' import validatorMiddleware from '@middy/validator' import { kebab } from 'change-case' const getHandler = middy() .before((request) =&gt; { const key = 'myId' request.event.pathParameters[kebab(key)] = request.event.pathParameters[key] delete request.event.pathParameters[key] }) .use(validatorMiddleware({eventSchema: {...} })) .handler((event, context) =&gt; { return { statusCode: 200, body: '{...}' } }) const postHandler = middy() .use(validatorMiddleware({eventSchema: {...} })) .handler((event, context) =&gt; { return { statusCode: 200, body: '{...}' } }) const routes = [ { method: 'GET', path: '/user/{myId}', // '/user/{my-id}' update to lowerCamelCase handler: getHandler }, { method: 'POST', path: '/user', handler: postHandler } ] export const handler = middy() .use(httpHeaderNormalizer()) .handler(httpRouterHandler(routes))  ","version":"Next","tagName":"h2"},{"title":"Upgrade 2.x -> 3.x","type":0,"sectionRef":"#","url":"/docs/upgrade/2-3","content":"","keywords":"","version":"Next"},{"title":"Notable changes​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#notable-changes","content":" New WebSocket middlewaresHTTP &amp; WebSocket Routers!Better error handlingTimeout error handlingErrors now use { cause } for better context  ","version":"Next","tagName":"h2"},{"title":"Core​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#core","content":" onError middleware stack order reversed to match after [Breaking Change] If you only use @middy/* middlewares no change should be requiredThis change has trickle down effects on middlewares with onError (see below for details)If you're handling errors yourself here are some things to review: Attach near the end so it is triggered first (likely already done)Remove return response, this will short circuit the response and block later middleware from modifying the response lambdaHandler now passes {signal} from AbortController to allow for ending lambda early to handle timeout errorsplugin argument now supports: internal: Allow the use of new Proxy() for smarter triggering in advanced use cases.timeoutEarlyInMillis: When before lambda timeout to trigger early exit. Default 5timeoutEarlyResponse: Function to throw a custom error or return a pre-set value. Default () =&gt; { throw new Error('Timeout') } Added .handler() method to allow easier understanding of the execution cycleDeprecate applyMiddleware() and __middlewares [Breaking Change]  ","version":"Next","tagName":"h2"},{"title":"Util​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#util","content":" getInternal error now includes cause set to an array of ErrorsCatch when X-Ray is applied outside of handler invocation scopenormalizeHttpResponse now takes request and mutates response [Breaking Change]getCache will return {} instead of undefined when not found [Breaking Change]  ","version":"Next","tagName":"h2"},{"title":"Middleware​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#middleware","content":" ","version":"Next","tagName":"h2"},{"title":"cloudwatch-metrics​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#cloudwatch-metrics","content":" No change  ","version":"Next","tagName":"h3"},{"title":"do-not-wait-for-empty-event-loop​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#do-not-wait-for-empty-event-loop","content":" No change  ","version":"Next","tagName":"h3"},{"title":"error-logger​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#error-logger","content":" No change  ","version":"Next","tagName":"h3"},{"title":"event-normalizer​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#event-normalizer","content":" Add support for all missing AWS eventsRefactored for performance improvements  ","version":"Next","tagName":"h3"},{"title":"http-content-encoding​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-content-encoding","content":" [New] Applies brotli, gzip, ands deflate compression to response body  ","version":"Next","tagName":"h3"},{"title":"http-content-negotiation​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-content-negotiation","content":" Add in defaultToFirstLanguage to allow fallback to a safe language to use  ","version":"Next","tagName":"h3"},{"title":"http-cors​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-cors","content":" onError will not modify response unless error has been handledSmall refactor for performance improvements  ","version":"Next","tagName":"h3"},{"title":"http-error-handler​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-error-handler","content":" No longer returns the response to short circuit the middleware stack to allow for easier use now that onError is called in reverse order.  ","version":"Next","tagName":"h3"},{"title":"http-event-normalizer​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-event-normalizer","content":" Option payloadFormatVersion no longer neededWill now throw error if not an http event [Breaking Change]  ","version":"Next","tagName":"h3"},{"title":"http-header-normalizer​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-header-normalizer","content":" Modified so that all headers are set to lowercase when canonical:false [Breaking Change]  ","version":"Next","tagName":"h3"},{"title":"http-json-body-parser​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-json-body-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-multipart-body-parser​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-multipart-body-parser","content":" Change default charset from binary/latin1 to utf-8. [Breaking Change]  ","version":"Next","tagName":"h3"},{"title":"http-partial-response​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-partial-response","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-response-serializer​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-response-serializer","content":" Renamed default option to defaultContentType to improve maintainability [Breaking Change]onError will not modify response unless error has been handled  ","version":"Next","tagName":"h3"},{"title":"http-router​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-router","content":" [New] Allow re-routing of events to different handlers  ","version":"Next","tagName":"h3"},{"title":"http-security-headers​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-security-headers","content":" onError will not modify response unless error has been handledComplete rewrite of options and inclusion of new HTML only headers [Breaking Change]  ","version":"Next","tagName":"h3"},{"title":"http-urlencode-body-parser​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-urlencode-body-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-urlencode-path-parser​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#http-urlencode-path-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"input-output-logger​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#input-output-logger","content":" Add in new option to mask instead of omit a path.  ","version":"Next","tagName":"h3"},{"title":"rds-signer​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#rds-signer","content":" Deprecated setToEnv option due to possible security misuse [Breaking Change]  ","version":"Next","tagName":"h3"},{"title":"s3-key-normalizer​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#s3-key-normalizer","content":" Deprecated in favour of event-normalizer, v2.x compatible with v3  ","version":"Next","tagName":"h3"},{"title":"s3-object-response​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#s3-object-response","content":" No change  ","version":"Next","tagName":"h3"},{"title":"secrets-manager​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#secrets-manager","content":" Deprecated setToEnv option due to possible security misuse [Breaking Change]  ","version":"Next","tagName":"h3"},{"title":"service-discovery​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#service-discovery","content":" [New] Allow easy access to discoveryInstances  ","version":"Next","tagName":"h3"},{"title":"sqs-json-body-parser​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#sqs-json-body-parser","content":" Deprecated in favour of event-normalizer, v2.x compatible with v3  ","version":"Next","tagName":"h3"},{"title":"sqs-partial-batch-failure​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#sqs-partial-batch-failure","content":" Complete rewrite to take advantage of https://aws.amazon.com/about-aws/whats-new/2021/11/aws-lambda-partial-batch-response-sqs-event-source/, will no longer throw an error if any message fails [Breaking Change]  ","version":"Next","tagName":"h3"},{"title":"ssm​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#ssm","content":" Deprecated setToEnv option [Breaking Change]  ","version":"Next","tagName":"h3"},{"title":"sts​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#sts","content":" No change  ","version":"Next","tagName":"h3"},{"title":"validator​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#validator","content":" Change where errors are stored, from request.error.details to request.error.cause [Breaking Change]Add new options eventSchema, contextSchema, responseSchema. inputSchema and outputSchema become aliases.  ","version":"Next","tagName":"h3"},{"title":"warmup​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#warmup","content":" No change  ","version":"Next","tagName":"h3"},{"title":"ws-json-body-parser​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#ws-json-body-parser","content":" [New] Parse body from WebSocket event  ","version":"Next","tagName":"h3"},{"title":"ws-response​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#ws-response","content":" [New] Post responses to WebSocket API Gateway  ","version":"Next","tagName":"h3"},{"title":"ws-router​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#ws-router","content":" [New] Allow re-routing of events to different handlers  ","version":"Next","tagName":"h3"},{"title":"Notes​","type":1,"pageTitle":"Upgrade 2.x -> 3.x","url":"/docs/upgrade/2-3#notes","content":" If you still need setToEnv you can do something like so:  middy(lambdaHandler) .use(/*...*/) .before(async (request) =&gt; { const values = await getInternal(['NODE_ENV'], request) process.env.NODE_ENV = values.NODE_ENV })  ","version":"Next","tagName":"h2"},{"title":"Upgrade 1.x -> 2.x","type":0,"sectionRef":"#","url":"/docs/upgrade/1-2","content":"","keywords":"","version":"Next"},{"title":"Core​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#core","content":" In handler callback(err, response) have been removed for async/await support return response to trigger after middleware stackthrow new Error(...) to trigger onError middleware stack In middleware next(err) has been removed for async/await support throw new Error(...) to trigger onError middleware stackreturn response to short circuit any middleware stack and respond. v1.x currently throws an error when something is returned  ","version":"Next","tagName":"h2"},{"title":"Middleware​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#middleware","content":" ","version":"Next","tagName":"h2"},{"title":"cache​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#cache","content":" Deprecated. Too generic and had low usage.  However, you can use the following if needed:  const { createHash } = require('crypto') module.exports = (opts) =&gt; { const storage = {} const defaults = { calculateCacheId: async (event) =&gt; createHash('md5').update(JSON.stringify(event)).digest('hex'), getValue: async (key) =&gt; storage[key], setValue: async (key, value) =&gt; { storage[key] = value } } const options = { ...defaults, ...opts } let currentCacheKey const cacheMiddlewareBefore = async (request) =&gt; { const cacheKey = await options.calculateCacheId(request.event) const response = await options.getValue(cacheKey) if (response) { return response } request.internal.cacheKey = cacheKey } const cacheMiddlewareAfter = async (request) =&gt; { await options.setValue(request.internal.cacheKey, request.response) } return { before: cacheMiddlewareBefore, after: cacheMiddlewareAfter } }   ","version":"Next","tagName":"h3"},{"title":"db-manager​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#db-manager","content":" Deprecated. Too generic and had low usage. You can check out middy-rds as a possible alternative or example on building your own replacement.  ","version":"Next","tagName":"h3"},{"title":"do-not-wait-for-empty-event-loop​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#do-not-wait-for-empty-event-loop","content":" No change  ","version":"Next","tagName":"h3"},{"title":"function-shield​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#function-shield","content":" Deprecated. Only supported up to Node v10.  ","version":"Next","tagName":"h3"},{"title":"http-content-negotiation​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#http-content-negotiation","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-cors​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#http-cors","content":" Added new options to support more headers  methodsexposeHeadersrequestHeadersrequestMethods  ","version":"Next","tagName":"h3"},{"title":"http-error-handler​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#http-error-handler","content":" Added in support to honour httpError.expose. Errors with statusCode &gt;= 500 are no longer applied to response by default. Added new option to catch any non-http and statusCode &gt;= 500 errors  fallbackMessage  ","version":"Next","tagName":"h3"},{"title":"http-event-normalizer​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#http-event-normalizer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-header-normalizer​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#http-header-normalizer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-json-body-parser​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#http-json-body-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-multipart-body-parser​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#http-multipart-body-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-partial-response​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#http-partial-response","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-response-serializer​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#http-response-serializer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-security-headers​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#http-security-headers","content":" No longer adds statusCode:500 when there is no response.  ","version":"Next","tagName":"h3"},{"title":"http-urlencode-body-parser​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#http-urlencode-body-parser","content":" Remove extended option. Only uses qs as the parser, formally enabled by options {extended: true}.  ","version":"Next","tagName":"h3"},{"title":"http-urlencode-path-parser​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#http-urlencode-path-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"input-output-logger​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#input-output-logger","content":" Now additionally logs response from the onError middleware stackSupport for omiting within nested arraysAdd in support for replacer to be passed into JSON.stringify()  ","version":"Next","tagName":"h3"},{"title":"rds-signer​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#rds-signer","content":" New middleware to fetch RDS credential used when connecting with IAM roles. This was built into db-manager.  ","version":"Next","tagName":"h3"},{"title":"s3-key-normalizer​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#s3-key-normalizer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"s3-object-response​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#s3-object-response","content":" New middleware to fetch and respond to S3 Object Get request event.  ","version":"Next","tagName":"h3"},{"title":"secrets-manager​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#secrets-manager","content":" Refactored, see documentation  ","version":"Next","tagName":"h3"},{"title":"sqs-json-body-parser​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#sqs-json-body-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"sqs-partial-batch-failure​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#sqs-partial-batch-failure","content":" Replaced option sqs with AwsClient and added in more options for control.  ","version":"Next","tagName":"h3"},{"title":"ssm​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#ssm","content":" Refactored, see documentation  ","version":"Next","tagName":"h3"},{"title":"sts​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#sts","content":" New middleware to fetch assume role credentials.  ","version":"Next","tagName":"h3"},{"title":"validator​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#validator","content":" Upgraded ajv and it's plugins to support JSON Schema Draft 2020-12 specification. Defaults were change because of this.  Plugin ajv-keywords removed from being included by default because it's quite a large package and usually only one keyword is used.Plugin ajv-errors removed from included by default because it conflicts with ajv-i18n when dealing with custom messages for multiple languages  ","version":"Next","tagName":"h3"},{"title":"warmup​","type":1,"pageTitle":"Upgrade 1.x -> 2.x","url":"/docs/upgrade/1-2#warmup","content":" Deprecated. This was a work round for a missing feature in AWS Lambda. AWS added in the ability to use provisioned concurrencyon 2019-12-03, removing the need for this work around.  However, you can use the following if needed:  middy(lambdaHandler).before((request) =&gt; { if (request.event.source === 'serverless-plugin-warmup') { console.log('Exiting early via warmup Middleware') return 'warmup' } })  ","version":"Next","tagName":"h3"},{"title":"Upgrade 5.x -> 6.x","type":0,"sectionRef":"#","url":"/docs/upgrade/5-6","content":"","keywords":"","version":"Next"},{"title":"Notable changes​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#notable-changes","content":" Support for --experimental-require-module. Introduced into nodejs 20.17, this allows for the import of ESM into CJS codebases, making the migration to ESM easier. See blog post from AWS (https://aws.amazon.com/blogs/compute/node-js-22-runtime-now-available-in-aws-lambda/) on usage.  ","version":"Next","tagName":"h2"},{"title":"Core​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#core","content":" Add in mechanise to handle undefined early responses. You can now set request.earlyResponse and it will respond with an undefined response. The existing method will continue to work as expected.  ","version":"Next","tagName":"h2"},{"title":"Util​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#util","content":" No change  ","version":"Next","tagName":"h2"},{"title":"Middleware​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#middleware","content":" ","version":"Next","tagName":"h2"},{"title":"appconfig​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#appconfig","content":" No change  ","version":"Next","tagName":"h2"},{"title":"cloudwatch-metrics​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#cloudwatch-metrics","content":" No change  ","version":"Next","tagName":"h3"},{"title":"do-not-wait-for-empty-event-loop​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#do-not-wait-for-empty-event-loop","content":" No change  ","version":"Next","tagName":"h3"},{"title":"error-logger​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#error-logger","content":" No change  ","version":"Next","tagName":"h3"},{"title":"event-normalizer​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#event-normalizer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-content-encoding​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-content-encoding","content":" Add in Vary support (#1253) Breaking ChangeAdd in support to skip encoding when Cache-Control: no-transform is used (#1252) breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-content-negotiation​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-content-negotiation","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-cors​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-cors","content":" The default origin is now undefined, defaulting to a secure state. Breaking ChangeRemove options (requestHeaders, requestMethods) to set request headers that are unused by the browser.Vary: origin now applied when more than one possible origin.  ","version":"Next","tagName":"h3"},{"title":"http-error-handler​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-error-handler","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-event-normalizer​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-event-normalizer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-header-normalizer​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-header-normalizer","content":" rawHeaders is no longer attached to event. Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-json-body-parser​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-json-body-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-multipart-body-parser​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-multipart-body-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-partial-response​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-partial-response","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-response-serializer​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-response-serializer","content":" deprecate use of event.requiredContentType. Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-router​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-router","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-security-headers​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-security-headers","content":" Add in support for Content-Security-Policy-Report-Only (#1248)Add in support for Reporting-Endpoints (#1249)  ","version":"Next","tagName":"h3"},{"title":"http-urlencode-body-parser​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-urlencode-body-parser","content":" replace use of qs with node:querystring. Complex nested object are no longer supported. Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-urlencode-path-parser​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#http-urlencode-path-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"input-output-logger​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#input-output-logger","content":" No change  ","version":"Next","tagName":"h3"},{"title":"rds-signer​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#rds-signer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"s3-object-response​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#s3-object-response","content":" No change  ","version":"Next","tagName":"h3"},{"title":"secrets-manager​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#secrets-manager","content":" No change  ","version":"Next","tagName":"h3"},{"title":"service-discovery​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#service-discovery","content":" No change  ","version":"Next","tagName":"h3"},{"title":"sqs-partial-batch-failure​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#sqs-partial-batch-failure","content":" No change  ","version":"Next","tagName":"h3"},{"title":"ssm​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#ssm","content":" No change  ","version":"Next","tagName":"h3"},{"title":"sts​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#sts","content":" No change  ","version":"Next","tagName":"h3"},{"title":"validator​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#validator","content":" No change  ","version":"Next","tagName":"h3"},{"title":"warmup​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#warmup","content":" No change  ","version":"Next","tagName":"h3"},{"title":"ws-json-body-parser​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#ws-json-body-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"ws-response​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#ws-response","content":" No change  ","version":"Next","tagName":"h3"},{"title":"ws-router​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#ws-router","content":" No change  ","version":"Next","tagName":"h3"},{"title":"Notes​","type":1,"pageTitle":"Upgrade 5.x -> 6.x","url":"/docs/upgrade/5-6#notes","content":" None ","version":"Next","tagName":"h2"},{"title":"Upgrade 3.x -> 4.x","type":0,"sectionRef":"#","url":"/docs/upgrade/3-4","content":"","keywords":"","version":"Next"},{"title":"Notable changes​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#notable-changes","content":" Middy now uses AWS SDK v3 by default.  ","version":"Next","tagName":"h2"},{"title":"Core​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#core","content":" Remove polyfill for AbortControlerRemove polyfill for timers/promises  ","version":"Next","tagName":"h2"},{"title":"Util​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#util","content":" normalizeResponse now will set the statusCode to 200 when casting to a new object or 500 when missing Breaking Change  ","version":"Next","tagName":"h2"},{"title":"Middleware​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#middleware","content":" ","version":"Next","tagName":"h2"},{"title":"cloudwatch-metrics​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#cloudwatch-metrics","content":" No change  ","version":"Next","tagName":"h3"},{"title":"do-not-wait-for-empty-event-loop​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#do-not-wait-for-empty-event-loop","content":" No change  ","version":"Next","tagName":"h3"},{"title":"error-logger​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#error-logger","content":" No change  ","version":"Next","tagName":"h3"},{"title":"event-normalizer​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#event-normalizer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-content-encoding​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-content-encoding","content":" Removed body as stream support, will be brought back as a new middleware in a future middleware Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-content-negotiation​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-content-negotiation","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-cors​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-cors","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-error-handler​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-error-handler","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-event-normalizer​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-event-normalizer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-header-normalizer​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-header-normalizer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-json-body-parser​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-json-body-parser","content":" Deprecate event.rawBody Breaking Change  You can add in an inline middleware as a workaround.   .before((request) =&gt; { request.event.rawBody = request.event.body }) .use(httpJSONBodyParserMiddleware())   See https://github.com/middyjs/middy/issues/945 for discussion and reasoning.  ","version":"Next","tagName":"h3"},{"title":"http-multipart-body-parser​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-multipart-body-parser","content":" Add new option to set charset  ","version":"Next","tagName":"h3"},{"title":"http-partial-response​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-partial-response","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-response-serializer​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-response-serializer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-router​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-router","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-security-headers​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-security-headers","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-urlencode-body-parser​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-urlencode-body-parser","content":" Now throws 422 when unable to parse JSON Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-urlencode-path-parser​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#http-urlencode-path-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"input-output-logger​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#input-output-logger","content":" No change  ","version":"Next","tagName":"h3"},{"title":"rds-signer​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#rds-signer","content":" Updated to use AWS SDK v3 Breaking Change  ","version":"Next","tagName":"h3"},{"title":"s3-object-response​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#s3-object-response","content":" Updated to use AWS SDK v3 Breaking Change  ","version":"Next","tagName":"h3"},{"title":"secrets-manager​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#secrets-manager","content":" Updated to use AWS SDK v3 Breaking Change  ","version":"Next","tagName":"h3"},{"title":"service-discovery​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#service-discovery","content":" Updated to use AWS SDK v3 Breaking Change  ","version":"Next","tagName":"h3"},{"title":"sqs-partial-batch-failure​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#sqs-partial-batch-failure","content":" No change  ","version":"Next","tagName":"h3"},{"title":"ssm​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#ssm","content":" Updated to use AWS SDK v3 Breaking Change  ","version":"Next","tagName":"h3"},{"title":"sts​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#sts","content":" Updated to use AWS SDK v3 Breaking Change  ","version":"Next","tagName":"h3"},{"title":"validator​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#validator","content":" We've put a lot of work into making this middleware bundle smaller and faster by default, while allowing for opting into more functionality.  Deprecate inputSchema and outputSchema options Breaking ChangeDeprecated i18nEnabled Breaking ChangeMust now pass in defaultLanguage localizations to languages Breaking ChangeAdded in ajv-error supportPulled transpileSchema out of middleware to allow for tree shaking and pre-compile option Breaking ChangeAdded in transpileLocale to allow for custom internationalization of error messages including errorMessage  How to update use of middleware  import validatorMiddleware from '@middy/validator' // 1. Import transpileSchema import { transpileSchema } from '@middy/validator/transpile' export const handler = middy(...) .use(validatorMiddleware({ // 2. Wrap schemas with transpileSchema eventSchema: transpileSchema(eventJsonSchema) }))   import validatorMiddleware from '@middy/validator' // 1. Import localizations import { en, fr } from 'ajv-ftl-i18n' export const handler = middy(...) .use(validatorMiddleware({ eventSchema: transpileSchema(eventJsonSchema), // 2. Add localizations in langauges: { en, fr } }))   ","version":"Next","tagName":"h3"},{"title":"warmup​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#warmup","content":" No change  ","version":"Next","tagName":"h3"},{"title":"ws-json-body-parser​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#ws-json-body-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"ws-response​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#ws-response","content":" Updated to use AWS SDK v3 Breaking Change  ","version":"Next","tagName":"h3"},{"title":"ws-router​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#ws-router","content":" No change  ","version":"Next","tagName":"h3"},{"title":"Notes​","type":1,"pageTitle":"Upgrade 3.x -> 4.x","url":"/docs/upgrade/3-4#notes","content":" None ","version":"Next","tagName":"h2"},{"title":"Upgrade 4.x -> 5.x","type":0,"sectionRef":"#","url":"/docs/upgrade/4-5","content":"","keywords":"","version":"Next"},{"title":"Notable changes​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#notable-changes","content":" Middy no longer support Common JS modules.Update to use TypeScript v5 along with a refactor to most packagesUpdate all errors to be consistent new Error('message', { cause: { package:'@middy/***', data:*** } })If using multiple http-*-body-parsers on the same endpoint you'll need to set disableContentTypeError:true  ","version":"Next","tagName":"h2"},{"title":"Why we deprecated CJS​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#why-we-deprecated-cjs","content":" ESM has been well supported in Lambda for almost 2 years nowESM is almost 2x faster than CJS at p95 Using Node.js ES modules and top-level await in AWS LambdaMaintainability; Maintaining a package to work with every transpilers and build tools that are constantly changing over time is hard and time consuming.  If you're not able to upgrade your codebase to using ESM yet, that's okay, v4.x is super stable and support CJS.  ","version":"Next","tagName":"h2"},{"title":"Core​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#core","content":" Updated plugin.timeoutEarlyResponse(...) to throw new error with name TimeoutError to match new AbortSignal.timeout().  ","version":"Next","tagName":"h2"},{"title":"Util​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#util","content":" No change  ","version":"Next","tagName":"h2"},{"title":"Middleware​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#middleware","content":" ","version":"Next","tagName":"h2"},{"title":"appconfig​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#appconfig","content":" Update SDK to use newer appconfigdata client Breaking Change  ","version":"Next","tagName":"h2"},{"title":"cloudwatch-metrics​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#cloudwatch-metrics","content":" No change  ","version":"Next","tagName":"h3"},{"title":"do-not-wait-for-empty-event-loop​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#do-not-wait-for-empty-event-loop","content":" No change  ","version":"Next","tagName":"h3"},{"title":"error-logger​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#error-logger","content":" Change logger to have request passed in instead of request.error by default to allow access request.context and request.event Breaking Change  ","version":"Next","tagName":"h3"},{"title":"event-normalizer​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#event-normalizer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-content-encoding​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-content-encoding","content":" Use preferredLanguage from context instead of event (See http-content-negotiation). Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-content-negotiation​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-content-negotiation","content":" Moved preferred* from event to context Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-cors​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-cors","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-error-handler​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-error-handler","content":" Will return 500 for all unhandled errors thrown Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-event-normalizer​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-event-normalizer","content":" Will no longer throw an error when HTTP type can't be determined Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-header-normalizer​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-header-normalizer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-json-body-parser​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-json-body-parser","content":" Change disableContentTypeError to false by default Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-multipart-body-parser​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-multipart-body-parser","content":" Change disableContentTypeError to false by default Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-partial-response​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-partial-response","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-response-serializer​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-response-serializer","content":" Removed parsing of Accept header in favour of using @middy/http-content-negotiation Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-router​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-router","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-security-headers​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-security-headers","content":" No change  ","version":"Next","tagName":"h3"},{"title":"http-urlencode-body-parser​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-urlencode-body-parser","content":" Change disableContentTypeError to false by default Breaking Change  ","version":"Next","tagName":"h3"},{"title":"http-urlencode-path-parser​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#http-urlencode-path-parser","content":" No change  ","version":"Next","tagName":"h3"},{"title":"input-output-logger​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#input-output-logger","content":" Updated to use structuredClone  ","version":"Next","tagName":"h3"},{"title":"rds-signer​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#rds-signer","content":" No change  ","version":"Next","tagName":"h3"},{"title":"s3-object-response​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#s3-object-response","content":" Refactored to use fetch over https. context now returns s3ObjectFetch to allow more control over how it's used. Breaking Change  ","version":"Next","tagName":"h3"},{"title":"secrets-manager​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#secrets-manager","content":" No change  ","version":"Next","tagName":"h3"},{"title":"service-discovery​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#service-discovery","content":" No change  ","version":"Next","tagName":"h3"},{"title":"sqs-partial-batch-failure​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#sqs-partial-batch-failure","content":" Will now catch unhandled errors and set all messages to failed, preventing infinite loops Breaking Change  ","version":"Next","tagName":"h3"},{"title":"ssm​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#ssm","content":" No change  ","version":"Next","tagName":"h3"},{"title":"sts​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#sts","content":" No change  ","version":"Next","tagName":"h3"},{"title":"validator​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#validator","content":" Use preferredLanguage from context instead of event (See http-content-negotiation).ajv-cmd is no longer a required dependency, if you're pre-transpiling you'll need to run npm i ajv-cmd.  ","version":"Next","tagName":"h3"},{"title":"warmup​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#warmup","content":" No change  ","version":"Next","tagName":"h3"},{"title":"ws-json-body-parser​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#ws-json-body-parser","content":" Remove inclusion of rawBody from event Breaking Change  ","version":"Next","tagName":"h3"},{"title":"ws-response​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#ws-response","content":" No change  ","version":"Next","tagName":"h3"},{"title":"ws-router​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#ws-router","content":" No change  ","version":"Next","tagName":"h3"},{"title":"Notes​","type":1,"pageTitle":"Upgrade 4.x -> 5.x","url":"/docs/upgrade/4-5#notes","content":" None ","version":"Next","tagName":"h2"},{"title":"Configurable Middlewares","type":0,"sectionRef":"#","url":"/docs/writing-middlewares/configurable-middlewares","content":"Configurable Middlewares In order to make middlewares configurable, they are generally exported as a function that accepts a configuration object. This function should then return the middleware object with before,after, and onError as keys. E.g. // customMiddleware.js const defaults = {} const customMiddleware = (opts) =&gt; { const options = { ...defaults, ...opts } const customMiddlewareBefore = async (request) =&gt; { const { event, context } = request // ... } const customMiddlewareAfter = async (request) =&gt; { const { response } = request // ... request.response = response } const customMiddlewareOnError = async (request) =&gt; { if (request.response === undefined) return await customMiddlewareAfter(request) } return { before: customMiddlewareBefore, after: customMiddlewareAfter, onError: customMiddlewareOnError } } export default customMiddleware With this convention in mind, using a middleware will always look like the following example: import middy from '@middy/core' import customMiddleware from 'customMiddleware.js' const lambdaHandler = async (event, context) =&gt; { // do stuff return {} } export const handler = middy() .use( customMiddleware({ option1: 'foo', option2: 'bar' }) ) .handler(lambdaHandler) ","keywords":"","version":"Next"},{"title":"Inline Middlewares","type":0,"sectionRef":"#","url":"/docs/writing-middlewares/inline-middlewares","content":"Inline Middlewares Sometimes you want to create handlers that serve a very small need and that are not necessarily re-usable. In such cases, you probably will need to hook only into one of the different phases (before, after or onError). In these cases you can use inline middlewares which are shortcut functions to hook logic into Middy's control flow. Let's see how inline middlewares work with a simple example: import middy from '@middy/core' const lambdaHandler = (event, context) =&gt; { // do stuff } export const handler = middy() .before(async (request) =&gt; { // do something in the before phase }) .after(async (request) =&gt; { // do something in the after phase }) .onError(async (request) =&gt; { // do something in the on error phase }) .handler(lambdaHandler) As you can see above, a middy instance also exposes the before, after and onErrormethods to allow you to quickly hook in simple inline middlewares.","keywords":"","version":"Next"},{"title":"Custom Middlewares","type":0,"sectionRef":"#","url":"/docs/writing-middlewares/intro","content":"Custom Middlewares A middleware is an object that should contain at least 1 of 3 possible keys: before: a function that is executed in the before phaseafter: a function that is executed in the after phaseonError: a function that is executed in case of errors before, after and onError functions need to have the following signature: const defaults = { // ... } const nameMiddleware = (opts = {}) =&gt; { const options = { ...defaults, ...opts } const nameMiddlewareBefore = async (request) =&gt; { // ... } const nameMiddlewareAfter = async (request) =&gt; { // ... } const nameMiddlewareOnError = async (request) =&gt; { // ... } return { before: nameMiddlewareBefore, after: nameMiddlewareAfter, onError: nameMiddlewareOnError } } export default nameMiddleware Where: request: is a reference to the current context and allows access to (and modification of) the current event (request), the response (in the after phase), and error(in case of an error).","keywords":"","version":"Next"},{"title":"Handle Timeouts","type":0,"sectionRef":"#","url":"/docs/writing-middlewares/timeouts","content":"Handle Timeouts When a lambda times out it throws an error that cannot be caught by middy. To work around this middy maintains an AbortController that can be signalled early to allow time to clean up and log the error properly. You can set timeoutEarlyInMillis to 0 to disable this functionality. If you want to override during testing, mock the lambda context to set getRemainingTimeInMillis to a function that returns a very large value (e.g. () =&gt; 99999). import middy from '@middy/core' const lambdaHandler = (event, context, { signal }) =&gt; { signal.onabort = () =&gt; { // cancel events } // ... } export const handler = middy({ timeoutEarlyInMillis: 50, timeoutEarlyResponse: () =&gt; { return { statusCode: 408 } } }).handler(lambdaHandler) ","keywords":"","version":"Next"},{"title":"Internal Storage","type":0,"sectionRef":"#","url":"/docs/writing-middlewares/internal-storage","content":"Internal Storage The handler also contains an internal object that can be used to store values securely between middlewares that expires when the event ends. To compliment this there is also a cache where middleware can store request promises. During before these promises can be stored into internal then resolved only when needed. This pattern is useful to take advantage of the async nature of node especially when you have multiple middleware that require reaching out the external APIs. Here is a middleware boilerplate using this pattern: import { canPrefetch, getInternal, processCache } from '@middy/util' const defaults = { fetchData: {}, // { internalKey: params } disablePrefetch: false, cacheKey: 'custom', cacheExpiry: -1, setToContext: false } const customMiddleware = (opts = {}) =&gt; { const options = { ...defaults, ...opts } const fetchRequest = () =&gt; { const values = {} // Start your custom fetch for (const internalKey of Object.keys(options.fetchData)) { values[internalKey] = fetchRequest('...', options.fetchData[internalKey]).then( (res) =&gt; res.text() ) } // End your custom fetch return values } if (canPrefetch(options)) { processCache(options, fetchRequest) } const customMiddlewareBefore = async (request) =&gt; { const { value } = processCache(options, fetchRequest, request) Object.assign(request.internal, value) if (options.setToContext) { const data = await getInternal(Object.keys(options.fetchData), request) Object.assign(request.context, data) } } return { before: customMiddlewareBefore } } export default customMiddleware ","keywords":"","version":"Next"},{"title":"More Examples","type":0,"sectionRef":"#","url":"/docs/writing-middlewares/more-examples","content":"More Examples Check the code for existing middlewares to see more examples on how to write a middleware.","keywords":"","version":"Next"},{"title":"With TypeScript","type":0,"sectionRef":"#","url":"/docs/writing-middlewares/with-typescript","content":"With TypeScript here's an example of how you can write a custom middleware for a Lambda receiving events from API Gateway: import middy from '@middy/core' import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda' const middleware = (): middy.MiddlewareObj&lt;APIGatewayProxyEvent, APIGatewayProxyResult&gt; =&gt; { const before: middy.MiddlewareFn&lt;APIGatewayProxyEvent, APIGatewayProxyResult&gt; = async ( request ): Promise&lt;APIGatewayProxyResult&gt; =&gt; { // Your middleware logic } const after: middy.MiddlewareFn&lt;APIGatewayProxyEvent, APIGatewayProxyResult&gt; = async ( request ): Promise&lt;undefined&gt; =&gt; { // Your middleware logic } return { before, after } } export default middleware Note: The Middy core team does not use TypeScript often and we can't certainly claim that we are TypeScript experts. We tried our best to come up with type definitions that should give TypeScript users a good experience. There is certainly room for improvement, so we would be more than happy to receive contributions 😊 See devDependencies for each middleware for list of dependencies that may be required with transpiling TypeScript.","keywords":"","version":"Next"}],"options":{"id":"default"}}